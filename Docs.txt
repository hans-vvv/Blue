.....

		
Handleiding LCM Migratie Manager
	



EGL Locaties	
		Hans Verkerk


Concept

Versie 0.6 
Versie datum 21 februari 2022

Rubricering Politie INTERN


 
Documentinformatie
Versiegeschiedenis
Versie	Versie datum	Samenvatting van de aanpassing	Gewijzigd door
0.1	06-04-2021	Initiële versie	Maurice Stoof
0.2	22-04-2021	Eerste review commentaar toegevoegd.	Hans Verkerk
0.3	22-06-2021	Nieuwe functionaliteiten toegevoegd	Hans Verkerk
0.4	6-9-2021	Integratie met Ansible 	Hans Verkerk
0.5	20-9-2021	Python scripts teruggebracht naar twee fasen en introductie van UniDesign tabel	Hans Verkerk
0.6	21-2-2022	Migratie naar Flask webinterface	Hans Verkerk









































© Politie, all rights reserved.
Niets uit deze uitgave mag worden verveelvoudigd, op geautomatiseerde wijze opgeslagen of openbaar gemaakt in enige vorm of op enigerlei wijze, hetzij elektronisch, mechanisch, door fotokopieën, opnamen of enige andere manier, zonder voorafgaande schriftelijke toestemming van de Politie.
Inhoudsopgave

Documentinformatie	2
Inhoudsopgave	3
Inleiding	4
Web interface	5
Site management	5
Voorbereiden migratie van een site	6
Invullen informatie in SiteMigration tab	6
Beoordelen van het resultaat van het Python script	7
Invullen informatie in UniDesign tab	8
Invullen informatie in SiteMigration tab	9
Invullen informatie in NniMigrate tab	9
Invullen informatie in SnmpLoc tab	9
Invullen informatie in DeviceVlanMap tab	10
Invullen informatie in C9500StackConfig tab	10
Genereren configuraties	11
Werkzaamheden tijdens fysieke LCM actie	11
Opslaan netwerktabellen van de huidige site	11
Kopiëren bestanden naar de staging area	11
Creëren van een inventory	12
Selecteren van een netwerkelement	12
Push de initiele configuratie	12
Push de AAA configuratie	12
Configuratie afmaken	12
Limitaties LCM tool	12




 
Inleiding
Een belangrijke activiteit van R&S is het life cycle management (LCM) van netwerk apparatuur op de zogenaamde EGL(Eind Gebruiker -) locaties.

Dit document dient als handleiding voor het gebruik van de “LCM Migratie” tool. Het doel van de tool is om IOS configuraties te genereren die bedoeld zijn voor nieuwe netwerkelementen die gebaseerd zijn op de Cisco 9300 en 9500 productlijn. Ook dient de tool om geautomatiseerd werkzaamheden uit te voeren die rondom een LCM actie moeten worden uitgevoerd. Denk hierbij aan het uploaden van een configuratie tijdens een migratie of het opslaan van laag-2 en laag-3 tabellen net voordat een LCM actie begint. Voor de laatste twee voorbeelden wordt het een combinatie van Python en Ansible scripting ingezet. Voor het genereren van de configuraties en het lezen en schrijven naar een Excel bestand zijn Python scripts gebruikt. De gebruikers interface is gerealiseerd m.b.v. het Python Flask web framework

De site specifieke data van een eindgebruiker locatie wordt geautomatiseerd overgenomen van de configuraties van de oude apparatuur. Denk hierbij aan VLAN’s, IP adressen, HSRP adressen etc. De tool maakt het ook mogelijk om een bestaande EGL-C setup te migreren naar een EGL-B setup. Ook is het mogelijk om migraties uit te voeren waarbij er niet 1-op-1 gemigreerd wordt. Een simpel voorbeeld hiervan is om een stack die bestaat uit vier chassis met elk 24-poorten te vervangen door een stack met twee chassis met elk 48 poorten. 

Een belangrijk uitgangspunt is dat er in principe geen wijzigingen nodig zijn aan de configuraties die door de tool zijn gegenereerd. Dit neemt echter niet weg dat er te allen tijde in de voorbereiding van een LCM actie tijd moet worden besteed of er mogelijke “specials” in de configuraties aanwezig zijn. Denk bijvoorbeeld aan glaskoppelingen in een ring, dynamische routeringsprotocollen, etc. Met de tool is het ook mogelijk om laag-2 en laag-3 poort informatie van alle bestaande switches op een site te bekijken; dit wordt namelijk in afzonderlijke tabs afgedrukt als de bestaande configuraties door de tool worden ingelezen. 

Als output van de tool worden een viertal configuraties geleverd per device. Preconfig / initial / afterconfig./ Final.

De preconfiguraties worden door Axians op de stacks aangebracht. Als een stack fysiek op de locatie is aangesloten tijdens de LCM actie, dan moet vanuit de webinterface de “initial” configuratie op de machines worden gezet. Als dit is gebeurd, dan kan er gestart worden met de migratie. Als de migratie fysiek is afgerond en als gecontroleerd is dat de migratie succesvol is verlopen, kan als laatste stap de “afterconfig” of AAA configuratie vanuit de webinterface op de machine worden gezet. Als laatste stap moet handmatig een aantal commando’s worden uitgevoerd als gecontroleerd is dat je succesvol met je token kunt inloggen op de machine

Het produceren van de configuraties van de nieuwe netwerkelementen gebeurt in een tweetal of drietal stappen: 
1.	Prepare van de nieuwe configuraties aan de hand van de oude device configuraties.
2.	Run (lees: genereren) van de nieuwe device configuraties
 
Web interface

De portal is bereikbaar via de volgende URL: https://netwerktools.politie.local/rstools/


Het proces rondom een LCM actie bestaat in principe uit een tweetal stappen:
1.	Voorbereiden van een migratie
2.	Het daadwerkelijk migreren van een site.

In de praktijk ligt er in de tijd gezien vaak enkele maanden tussen de twee momenten.

Site management
Voordat gestart wordt met het voorbereiden of het migreren van een site, moet eerst de site geselecteerd worden door op de knop “Selecteren van een site” te drukken. Hierna moet op de knop “Klaarzetten scripting omgeving ” worden gedrukt. Dit laatste zorgt ervoor dat alle benodigde scripts gekopieerd worden. Voor elke site wordt dus een aparte set van scripts gebruikt. Hiermee wordt het mogelijk gemaakt dat LCM migraties parallel uitgevoerd kunnen worden.

 
 
Voorbereiden migratie van een site
 


Allereerst moet een nieuw Excel bestand worden gedownload als nog niet eerder configuraties zijn gegenereerd met de tool. Het Excel bestand wordt in twee of drie “ronden” gevuld met data. 
Invullen informatie in SiteMigration tab

Als eerste moeten een aantal velden in de SiteMigration tab worden ingevuld. 
 


De volgende velden moeten worden ingevuld:
•	SiteName: Gebruik hiervoor de combinatie van regio- en gebouwcode.
•	OldDeviceName: De naam of namen van de oude netwerkelementen.
•	OldDeviceRole: De ‘role’ (router of switch) van de oude netwerkelementen.
•	NewDeviceName: De naam of namen van de nieuwe netwerkelementen.
•	NewDeviceRole: : De ‘role’ (router of switch) van de nieuwe netwerkelementen.

Let op dat er kleine letters worden gebruikt bij het invullen.
Als de gevraagde informatie is ingevuld, upload dan de file naar de server. Let hierbij op dat de naam van het bestand altijd gelijk moet zijn aan result.xlsx

Als het bestand is geupload, druk dan op de link “Maak een inventory van de bestaande machines (LCM)”. Dit zorgt ervoor dat het mogelijk wordt gemaakt dat er backups van de bestaande machines kunnen worden gemaakt. Druk dus vervolgens op de link “Maak backups van de bestaande machines (LCM)”

Als voorlopige laatste stap moet op de link “Bereid de configuraties voor (LCM)” worden gedrukt. Het achterliggende script zorgt ervoor dat het Excel bestand wordt aangevuld met data van de oude netwerkelementen. Druk op link “Download een bestaand Excel bestand” om het bestand te downloaden.
Beoordelen van het resultaat van het Python script

Als het result.xlsx wordt geopend, zien we dat in de Sitemigration tab het FromVlan, ToVlan, VlanType en BaseVlanName veld is ingevuld. De laatste drie kolommen worden d.m.v. lookup tabellen aangevuld. Het is van belang om te controleren of de informatie correct is. Zoals in het onderstaande voorbeeld te zien is, is het soms wenselijk om Vlan’s niet mee te migreren. Zorg er dan voor dat het ToVlan, VlanType en BaseVlanName veld leeg is. Indien Vlan3 aanwezig is op een locatie gebeurt dit al automatisch in de sheet.













De betekenis van de velden is: 
•	FromVlan en ToVlan bevat de vlans die er nu zijn en die gemigreerd worden. Het is dus mogelijk om VLAN’s niet te migreren.
•	VlanType is een keuze uit 4 mogelijkheden (transit, mgmt, data, voice) De categorieën worden in het script gebruikt om de business logica te implementeren. De transit VLAN’s liggen normaalgesproken in de range 11 t/m 50 en worden gebruikt om verkeer met KPN uit te wisselen. Met “mgmt” VLAN is ten behoeve van management en is normaalgesproken gelijk aan 99. Het data VLAN ligt tussen 100 en 119. Dit VLAN wordt op een site gebruikt voor alle standaard devices, dus PC’s, printers, kluizen, etc. Het voice VLAN wordt gebruikt voor IP telefonie en is gelijk aan 497.
•	BaseVlanName wordt alleen gebruikt voor Legacy vlans die we nog niet kunnen uitfaseren en dus mee moeten nemen. Hier geef je de naam op.

Als laatste moeten we hier het VRF invullen waar het in leeft, dus dit kan de volgende opties hebben: 
•	pol 
•	mk
•	gbs
•	par
•	irn
•	trf
•	internet
•	koo
•	lon
Dit wordt alleen aangevuld bij een laag3 VLAN. Bij de rest kan het leeg gelaten worden. Ook hier wordt door het script een suggestie gedaan welk VRF er bij het VLAN hoort. 

Invullen informatie in UniDesign tab

In deze tabel wordt het nieuwe hardware design van een site opgenomen. 
 

De kolommen D t/m G moeten worden aangevuld met informatie. Het doel van deze tabel is om te bepalen welke hardware configuratie er op een site ingezet gaat worden. De tabel maakt het mogelijk om op een aantal manieren niet 1-op-1 te migreren. Een aantal voorbeelden zijn:

•	In de rijen 2 t/m 5 wordt een stack die bestond uit 4 chassis met elk 24 poorten vervangen door een stack met 2 chassis bestaande uit elk 48 poorten. Het lijkt er misschien in eerste instantie op dat de nieuwe stack uit vier chassis bestaat, maar in kolom E (NewSeq) is te zien dat 1 en 2 meerdere malen voorkomt. In dit geval wordt de stack amlsjws01 vervangen door de stack amsls03301. Alle rijen, in dit geval dus 2 t/m 5 moeten gevuld zijn met informatie. 
•	In de rijen 6 t/m 8 wordt een stack bestaande uit 3 chassis met elk 24 poorten vervangen door een stack bestaande uit 1 chassis met 48 poorten.
•	In de rijen 9 t/m 11 vindt een 1-op-1 vervanging plaats.
•	In de rijen 12 t/m 15 vindt een identieke migratie plaats als in de rijen 2 t/m 5.
•	Idem rijen 16 t/m 19.
•	In de rijen 20 t/m 23 wordt een stack bestaande uit 4 chassis met elk 24 poorten vervangen door een stack bestaande uit 3 chassis met elk 24 poorten.
•	In de rijen 24 t/m 29 worden twee stacks met elk 3 chassis en 24 poorten vervangen door 1 stack met 3 chassis en elk 48 poorten. Let op dat in het derde chassis (en in andere voorkomende gevallen het vierde chassis)  nooit een uplink module aanwezig is.

Invullen informatie in SiteMigration tab


 

De kolommen NewMgmtPrefix en NewMgmtGw moeten worden aangevuld. De informatie in de kolommen OldMgmtPrefix en OldMgmtGw kan gebruikt worden om te worden gekopieerd naar de eerstgenoemde twee kolommen.

Invullen informatie in NniMigrate tab

In deze tabel worden de interfaces gereserveerd t.b.v. de WAN koppeling(en).

 

In het meest voorkomende geval is er een routerende stack aanwezig met ten minste twee chassis. Indien dit het geval is worden er altijd twee interfaces gereserveerd voor de WAN koppelingen. Als de site een EGL-B klasse is, dan wordt GigabitEthernet2/0/48 als backup interface ingezet van GigabitEthernet1/0/48. Als de stack uit 1 chassis bestaat, dan wordt er geen backup interface gereserveerd. De uplink kolom moet voor WAN verbindingen altijd op ‘yes’ worden gezet. 

Als in een rij van de tabel alleen de kolommen C en D ingevuld zijn, dan worden die poorten niet toegewezen om netwerkelementen op een site met elkaar te verbinden. Dit moet worden gebruikt als op een EGL-C site op TenGigabitEthernet1/0/16 de PLTM routers worden aangesloten. De interface TenGigabitEthernet1/0/15 moet dan gereserveerd worden op beide routers, zodat de logica van het script ervoor zorgt dat de interfaces TenGigabitEthernet1/0/13 en TenGigabitEthernet1/0/14 gereserveerd worden om de EGL-C routers met elkaar te verbinden. Dit is namelijk de algemeen geldende ontwerpregel. 
 
Invullen informatie in SnmpLoc tab

In de tab SnmpLoc moet de juiste snmp-server location string worden toegevoegd. De oude informatie in kolom B kan desgenwenste gekopieerd worden naar kolom D.

 


Invullen informatie in DeviceVlanMap tab

De aanvullende informatie  in de tabel “DeviceVlanMap” dient optioneel ingevuld te worden. Als ten gevolg van het nieuwe design van een site twee bestaande stacks samengevoegd worden tot een enkele stack, dan kan het gebeuren dat  in beide oude stacks verschillende data Vlans worden gebruikt, bijvoorbeeld de Vlans 100 en 101. Als deze stacks samengevoegd worden, dan moet in de tabel worden aangegeven wat het nieuwe data Vlan van de stack wordt, in dit geval dus 100 of 101. Een belangrijk punt om in het achterhoofd te houden als opnieuw de data Vlans worden toegewezen is om de subnet grootte van het Vlan te gebruiken om te bepalen hoeveel access poorten er in het Vlan actief kunnen zijn.  Verder moet dezelfde tabel worden aangevuld als 802.1x op de site aanwezig is, de nieuwe confi VLAN’s moeten dan ook worden toegewezen.

 

Het script genereert een foutmelding als de twee beschreven toestanden worden gedetecteerd. De tabel moet dan worden aangevuld en het script moet weer worden uitgevoerd. 

Invullen informatie in C9500StackConfig tab

 

In de tab UniDesign wordt in de meest voorkomende gevallen het nieuwe hardware design vastgelegd. Als er echter gebruik wordt gemaakt van C9500 switches, dan moet de informatie over deze netwerkelementen in de tabel worden opgenomen.

Let op: Als op een bestaande MER ruimte slechts 1 of 2 3750 glas switches aanwezig zijn met enkel een routerende rol, dan wordt in de regel deze switch of switches vervangen door 1 of 2 C9300-24P devices met een NM-8X uplink module. Omdat er dan in principe geen koperpoorten beschikbaar hoeven te zijn, moet de stack configuratie in dit geval als uitzondering in de C9500StackConfig tabel worden opgenomen.



Genereren configuraties

Als alle informatie is ingevuld, moet het bestand weer worden geüpload naar de server. Let hierbij op dat de naam van het bestand gelijk is aan result.xlsx. Als dit is gebeurd, moet op de link “Genereer de configuraties (LCM)” worden gedrukt. Alle configuraties kunnen worden gedownload in een zip formaat

Werkzaamheden tijdens fysieke LCM actie
Allereerst moet worden opgemerkt dat de hiervoor beschreven activiteiten een dag voor de migratie opnieuw moeten worden uitgevoerd. Ook wordt aanbevolen om in het Site Management menu opnieuw de scripting omgeving klaar te zetten. Download dan een gearchiveerd Excel bestand van een specifieke site. In de SiteMigration tab moet in Kolom A het veld “VlanMapDone” leeg worden gemaakt en moet opnieuw alle stappen doorlopen worden. Echter blijft alle eerder ingevoerde informatie bestaan, behalve de kolommen FromVlan, ToVlan, VlanType en BaseVlanName in de SiteMigration tab. De reden is namelijk dat er in de tussentijd soms Vlans bijgekomen kunnen zijn. Als op de link “Bereid de configuraties voor (LCM)” is gedrukt moet dus opnieuw beoordeeld worden of in de eerdergenoemde kolommen de informatie correct is. Uiteindelijk moeten dus de definitieve configuraties opnieuw gegenereerd worden.

 

Opslaan netwerktabellen van de huidige site

Door op de link “Sla netwerktabellen van de huidige site op (LCM)” worden de MAC en DHCP snooping tabellen van de bestaande site opgeslagen. Deze kunnen later worden geraadpleegd tijdens troubleshooten als hier behoefte aan is.

Kopiëren bestanden naar de staging area

Door op de link “Kopieer configuraties naar de staging area” te drukken worden de configuraties naar een aparte directory op de server gezet. Het doel hiervan is dat er een mogelijkheid is om handmatig de configuraties te kunnen editen. Er zijn een aantal links waarmee de bestanden kunnen worden geüpload en gedownload, zodat ze desgewenst aangepast kunnen worden. Let hierbij op dat de bestanden hun originele naam hebben als ze weer geüpload worden naar de server.

Creëren van een inventory

Door op de link “creëer een inventory” te drukken wordt ervoor gezorgd dat in de volgende stap de netwerkelementen en de bijbehorende IP adressen m.b.v. een drop-down menu geselecteerd kunnen worden.

Selecteren van een netwerkelement

Als de nieuwe netwerkelementen die voorzien zijn van een preconfig zijn aangesloten, dan kunnen deze voorzien worden van een initiële configuratie. Met deze configuratie kan de fysieke migratie gestart worden. Dit betekent dus dat alle laag-2 en laag-3 configuratie dan aanwezig is. In bepaalde gevallen worden tijdelijke IP adressen voor de nieuwe netwerkelementen gebruikt. Dit wordt gedaan omdat er overlap kan ontstaan met management IP adressen van bestaande, oude devices. Er moet daarom zowel het (tijdelijke) IP adres en de hostname worden opgegeven. Als het tijdelijke IP adres van de switch niet overeenkomt met de hostnaam van de switch, wordt de configuratie niet geupload en verschijnt een foutmelding.

Push de initiele configuratie

Als het netwerkelement is geselecteerd, dan moet de configuratie worden geupload. Als op de link “Push de initiele configuratie” wordt gedrukt, dan zorgt een script dat eerst de configuratie naar flash: wordt gekopieerd en dat hierna deze file met de running-config wordt gemerged. 

Push de AAA configuratie

Als de migratie fysiek is afgerond, dan moet de configuratie worden afgemaakt. Als eerste moet de productie AAA configuratie op de machine worden gezet. Hiervoor moet eerst het juiste netwerkelement met het bijbehorende definitieve IP adres worden geselecteerd. Hierna moet op link “Push de AAA configuratie” worden gedrukt. Zorg dat je ingelogd bent met het cisco/cisco account voordat je de actie uitvoert. Als de actie is uitgevoerd, log dan in met een nieuw window met een keepass wachtwoord. Als dit succesvol verloopt, dan kan de configuratie worden afgemaakt. 

Configuratie afmaken

Voer de configuratie met de hand in die hieronder is aangehecht.
 

Limitaties LCM tool
De volgende bekende beperkingen bestaan:

•	De tool ondersteunt geen migraties van switches in een EGL-A configuratie. 
•	Als er laag-3 interfaces aanwezig zijn (uitgezonderd Vlan1) zonder IP adres, crasht het script. Controleer daarom altijd na het “voorbereiden” van de configuraties in de tab OldPortInfo of dit het geval is. Als dit zo is, migreer dan het Vlan niet mee.
•	Als op een EGL-C locatie bijvoorbeeld IRN niet redundant is aangesloten, klapt het script er uit. De configuratie hiervoor moet achteraf met de hand worden teruggezet en de Vlans kunnen dus niet mee worden gemigreerd met het script. Het is belangrijk dat van te voren een inventarisatie m.b.v. De Excel autofilter feature plaatsvindt welke originele poorten in het VLAN zitten. Deze poorten moeten dan handmatig aan de van-naar lijsten worden toegevoegd.
•	26xx, 35xx, 3650 en 3850 switch kunnen niet gemigreerd worden naar 9300/9500. 
•	Hostnames van bestaande en nieuwe switches moeten met kleine letters worden ingevoerd.
•	Dynamische routeringsprotocollen worden niet meegemigreerd.

###########################################
###########################################


.....

		
R&S tools web frontend
	



R&S tools	
		Hans Verkerk


Concept

Versie 0.1
Versie datum 28 februari 2022

Rubricering Politie INTERN


 
Documentinformatie
Versiegeschiedenis
Versie	Versie datum	Samenvatting van de aanpassing	Gewijzigd door
0.1	28-02-2022	Initiële versie	Hans Verkerk
			
			
			
			
			









































© Politie, all rights reserved.
Niets uit deze uitgave mag worden verveelvoudigd, op geautomatiseerde wijze opgeslagen of openbaar gemaakt in enige vorm of op enigerlei wijze, hetzij elektronisch, mechanisch, door fotokopieën, opnamen of enige andere manier, zonder voorafgaande schriftelijke toestemming van de Politie.
Inhoudsopgave

Documentinformatie	2
Inhoudsopgave	3
Inleiding	4
Python Flask web framework	5
Inleiding	5
WSGI interface	5
Flask applicatie	6
Andere globale bestanden en directories	7
Database setup	8
Database tabellen structuur (models)	8
Database ORM CRUD operations	8
Database file	9
Web forms	9
Algemene HTML en CCS opmaak van de portal	9
HTML	9
CSS	11
Utilities	11
Cookie reader	11
Scripts_wrapper	12
Breadcrumbs	12
Site Authorisatie	13
Flask blueprints	14
Views en routing	14
Flask session objecten	15
Templates	15
Admin portal	15
LCM portal	15
Onderhoud	17
Troubleshooting	17
Activeren nieuwe configuratie	17




 
Inleiding
Voor u ligt een document waarin het design beschreven is van een Python Flask webportal waarmee “automation” scripts achter een User Interface “embedded” kunnen worden.

De aanleiding om half december 2021 te starten met het ontwikkelen van de portal is om het LCM proces wat uitgewerkt is in een aantal losse Python en Ansible scripts verder te professionaliseren door vooral de gebruikersvriendelijkheid en daarmee de toepasbaarheid te vergroten. Uiteindelijk is er een full-stack applicatie ontwikkeld met een Python/Ansible backend, een Python Flask frontend en een Sqlite database met een Python Sqlalchemy ORM.

De ontwikkeling had nooit zo snel kunnen plaatsvinden als niet gebruik was gemaakt van functionaliteiten die al op de server aanwezig waren waarop de portal uiteindelijk is ontwikkeld. Op de isivsx0024 server waren namelijk Windows kerberos authenticatie, LDAP integratie, SSL en een Apache webserver al aanwezig. Met een Python utilitity script die cookies van clients uitleest aan de bestaande operationele kant van de server en een aantal minimale aanpassingen aan de bestaande configuratie van de server, bleek al vrij snel dat de Python Flask integratie in principe gemakkelijk mogelijk was op de server.

Dit document beschrijft de opzet van de Flask applicatie. Er is nadrukkelijk naar gestreefd om deze modulair op te zetten. Hiervoor is gebruik gemaakt van de Flask “Blueprint” feature. Met deze feature wordt het mogelijk gemaakt om afzonderlijke applicaties op de server in afzonderlijke bestanden en directories te configureren om zodoende de beheersbaarheid van het geheel van applicaties te vergroten. Momenteel zijn er een tweetal applicaties op de portal aanwezig, de LCM applicatie en een “applicatie” die in wezen een klein, maar bruikbaar Python script is. Er wordt beschreven wat je precies moet doen om een dergelijk Python script beschikbaar te maken voor een gebruiker via de web interface. Ook wordt kort stilgestaan bij een tweetal noodgedwongen keuzes die gemaakt zijn, omdat bepaalde, beter geachte, alternatieven niet bleken te werken.


 
Python Flask web framework

Inleiding

Flask is een zogenaamd micro web framework. Dit betekent dat de “core” relatief simpel is. Dit moedigt aan dat developers zelf extensies kunnen maken en deze via Github of andere manieren kunnen distribueren. Het is een relatief eenvoudig, maar toch schaalbaar framework om websites mee te bouwen. Er zijn op Internet talloze tutorials te vinden waarin de werking van de verschillende features wordt beschreven. Ook zijn er talloze boeken te koop. Je staat dus als developer niet alleen en “Google is your friend” als je tegen een probleem aanloopt.

Flask is standaard uitgerust met een zogenaamde Development webserver. Deze server draait standaard op een hoge TCP poort. Het voordeel van deze server is dat er debugging tools in zitten. Het nadeel in de specifieke Politie omgeving is dat er geen user (cookie) informatie aanwezig is in de Development omgeving. Ik persoonlijk vind het overkomelijk om in de productie omgeving te ontwikkelen. Het komt vrijwel niet voor dat als gevolg van een fout de complete site niet beschikbaar is. Wel denk ik dat het aan te bevelen is om tijdens LCM acties (voorbereidingen en uitvoering) geen werkzaamheden op de server uit te voeren. Beter is het nog om te zorgen voor een test – en acceptatie omgeving. 

WSGI interface

Een Web Server Gateway Interface is een gestandaardiseerde interface waarin beschreven is hoe een webserver moet connecteren met een Python web framework. De configuratie van de WSGI interface bevindt zich in de root van het project in het rstools.wsgi Python script.

[isn78253@isivsx0024 ~]$ cd /var/www/html/rstools
[isn78253@isivsx0024 rstools]$ ls -la
total 12
drwxrwxrwx   7 rstools root      106 Feb 17 16:39 .
drwxr-xr-x. 12 root    root     4096 Feb 17 15:55 ..
drwxr-xr-x   2 rstools root      318 Jan 14 11:39 bin
drwxrwxr-x   8 rstools isn78253  166 Feb 17 16:30 .git
-rw-r--r--   1 rstools isn78253  251 Feb 17 16:30 .gitignore
drwxr-xr-x   3 rstools root       23 Jan 14 11:37 lib
drwxr-xr-x   3 rstools root       23 Jan 14 11:37 lib64
drwxrwxrwx   9 rstools root      214 Feb 22 06:02 rstools
-rw-r--r--   1 rstools root      338 Feb  6 09:12 rstools.wsgi


In de file rstools.wsgi wordt een applicatie object aangemaakt die door de Apache webserver wordt gebruikt om te kunnen communiceren met het Flask framework

#!/usr/bin/python3

import logging
import sys


sys.path.insert(0,"/var/www/html/rstools/rstools/")

from rstools import create_app
application = create_app()


Flask applicatie

In de directory /var/www/html/rstools/rstools/ bevindt zich de globale configuratie van de portal in de file rstools.py

import os
import sys
import logging
import inspect
from contextlib import contextmanager
from models import Session
from flask import Flask, session


def setup_app(app):

    @app.before_first_request
    def before_first_request():

        app.jinja_env.filters['zip'] = zip

        log_level = logging.DEBUG
        for handler in app.logger.handlers:
            app.logger.removeHandler(handler)
        root = os.path.dirname(os.path.abspath(__file__))
        logdir = os.path.join(root, 'logs')
        if not os.path.exists(logdir):
            os.mkdir(logdir)
        log_file = os.path.join(logdir, 'app.log')
        #log_file = 'app.log'
        handler = logging.getLogger("LCM App")
        formatter = logging.Formatter(
        """%(asctime)s,%(levelname)s in %(module)s, [%(pathname)s:%(lineno)d]:\n%(message)s"""
        )
        handler = logging.FileHandler(log_file)
        handler.setFormatter(formatter)
        handler.setLevel(log_level)
        app.logger.addHandler(handler)
        app.logger.setLevel(log_level)


def create_app():

    app = Flask(__name__)
    app.config.from_object('config.Config')

    from sqlalchemy import event
    from sqlalchemy.engine import Engine
    from sqlite3 import Connection as SQLite3Connection
    from sqlalchemy.exc import IntegrityError

    @event.listens_for(Engine, "connect")
    def _set_sqlite_pragma(dbapi_connection, connection_record):
        if isinstance(dbapi_connection, SQLite3Connection):
            cursor = dbapi_connection.cursor()
            cursor.execute("PRAGMA foreign_keys=ON;")
            cursor.close()

    from apps.admin.views import admin
    from apps.lcm.views import lcm
    from apps.port_uptime.views import port_uptime

    app.register_blueprint(admin)
    app.register_blueprint(lcm)
    app.register_blueprint(port_uptime)
    setup_app(app)

    return app


De file zijn globaal de volgende zaken aanwezig:

•	De setup van de app -> app = Flask(__name__)
•	Het importeren van configuratie items uit de file config.py die zich in dezelfde directory bevindt. 
•	Een extensie om in de HTML templates gebruik te kunnen maken van de Python zip feature.
•	De logging configuratie van de app
•	De setup van de sqlite dB die ervoor zorgt dat referential integrity checks worden uitgevoerd.
•	Het registeren van de verschillende blueprints (applicaties)

Andere globale bestanden en directories

[isn78253@isivsx0024 rstools]$ ls -la
total 76
drwxrwxrwx 9 rstools root     214 Feb 22 06:02 .
drwxrwxrwx 7 rstools root     106 Feb 17 16:39 ..
drwxr-xr-x 6 rstools root      87 Feb 15 11:59 apps
drwxr-xr-x 4 rstools root     201 Feb 17 15:49 archive
-rw-r--r-- 1 rstools root     381 Feb  3 16:45 config.py
-rwxrwxrwx 1 rstools root     606 Feb  4 15:59 db_create.py
-rw-r--r-- 1 rstools root    2282 Feb 21 14:57 forms.py
drwxr-xr-x 2 rstools root      21 Feb 10 15:46 logs
-rwxrwxrwx 1 rstools root    1473 Feb 15 14:10 models.py
drwxr-xr-x 2 rstools apache   148 Feb 16 10:31 __pycache__
-rwxrwxrwx 1 rstools root   57344 Feb 22 06:02 rstools.db
-rwxr-xr-x 1 rstools root    1880 Feb 15 13:34 rstools.py
drwxr-xr-x 5 rstools root      38 Feb 17 16:14 static
drwxr-xr-x 2 rstools root      50 Feb  7 07:33 templates
drwxr-xr-x 3 rstools root      41 Feb 22 07:28 utils


•	In de directory apps bevinden zich een drietal subdirectories. In elke subdirectory zijn configuratie bestanden van het admin gedeelte, het LCM gedeelte en het “port uptime” gedeelte van de portal.
•	In het bestand config.py zijn verdere instellingen van de applicatie opgenomen
•	Het script db_create.py bevat de initiële configuratie van de database. Het is nadrukkelijk niet de bedoeling om dit script te runnen, omdat daarmee de complete database geleegd wordt.
•	In forms.py staan verschillende soorten webforms die in het project worden gebruikt.
•	In models.py zijn de database tabellen structuur t.b.v. de admin interface opgenomen. Ook is een tabel opgenomen die in de LCM app wordt gebruikt.
•	In de file rstools.db is de sqlite database aanwezig.
•	In de directory static zijn HTML en CSS files aanwezig
•	In de directory templates zijn de basis HTML files van de hele portal aanwezig.
•	In de directory utils zijn een aantal utilitiy functies aanwezig.




Database setup

In de portal wordt gebruik gemaakt van een sqlite database. Dit is een eenvoudige maar krachtige database en is zeker goed genoeg voor het doel waarvoor deze aanwezig is in de portal, namelijk voor administratie van user accounts van applicaties. 

Naast de database wordt gebruik gemaakt van de sqlalchemy ORM. Dit is een tool waarmee de database benaderd en beheerd kan worden met Python objecten. Dit betekent dat weinig tot geen kennis nodig is van SQL taal. Dit betekent overigens niet dat geen kennis van database design nodig is. 

Het is redelijke gebruikelijk om een Flask extensie te gebruiken, namelijk flask_sqlalchemy. Tijdens het testen van deze extensie bleek de complete portal instabiel te zijn. Daarom is afgezien van deze extensie en is gebruik gemaakt van het “native” sqlalchemy project. Uiteindelijk is dit niet onoverkomelijk omdat de extensie weinig tot geen voordelen biedt in de vorm van extra geboden functionaliteit. 

Database tabellen structuur (models)

users_userroles = Table(
    'users_userroles', Base.metadata,
    Column('user_id', ForeignKey('users.id'), primary_key=True, index=True),
    Column('userrole_id', ForeignKey('userroles.id'), primary_key=True, index=True),
)


class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, unique=True)
    userroles = relationship('UserRole', secondary=users_userroles, back_populates='users')

    def __repr__(self):
        return "<User(id={})>".format(self.id)


class UserRole(Base):
    __tablename__ = 'userroles'

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, unique=True)
    users = relationship('User', secondary=users_userroles, back_populates='userroles')


class Site(Base):
    __tablename__ = 'sites'

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, unique=True)

Zoals te zien is, is de opmaak van de tabellen in de vorm van Python objecten. De User en UserRole tabellen zijn m.b.v. een “many-to-many” relatie gekoppeld. De Site tabel is niet gekoppeld.

Database ORM CRUD operations 

In de verschillende views files van de applicaties zijn een groot aantal voorbeelden te vinden waarin onder andere:
•	Een user wordt toegevoegd
•	Een user wordt verwijderd
•	Opgevraagd wordt welke users er zijn
•	Een user wordt toegevoegd aan een Role.
•	Enz, enz.

In het onderstaande specifieke voorbeeld wordt een User object opgevraagd op basis van de unieke naam van de user. Vervolgens worden de gebruikersrollen opgevraagd die bij de User horen. Er wordt gebruik gemaakt van een zogenaamde context manager (with …), zodat transacties rondom een database operatie altijd automatisch netjes worden afgesloten.
with session_scope() as s:
    user = s.query(User).filter_by(name=session['shortname'].upper()).first()
    userroles = s.query(UserRole).filter(UserRole.users.any(id=user.id)).all()
    user_rolenames = [userrole.name for userrole in userroles]

Database file

De database file rstools.db bevindt zich op disk in de directory  /var/www/html/rstools/rstools/

Web forms

In de file forms.py zijn een aantal forms gedefinieerd waarmee een gebruiker van de applicatie data kan invoeren. Een voorbeeld is hieronder gegeven.

class AddUserForm(FlaskForm):
    username = StringField('Gebruikersnaam')
    userrole = SelectField('Gebruikersrol', choices = [])


 

De gebruikersrol kan m.b.v. een scroll-down bar geselecteerd worden. Vandaar dat in de definitie van de Form een lijst genaamd choices aanwezig is bij de definitie van de userrole.

Algemene HTML en CCS opmaak van de portal

HTML

In de directory /var/www/html/rstools/rstools/templates zijn een tweetal HTML files aanwezig. In de file _base.html is de opmaak van de portal gedefinieerd. Er is gebruik gemaakt van Bootstrap CSS om de opmaak te vereenvoudigen. 

<!DOCTYPE html>
<html>
<head>
    <title>LCM<</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/bootstrap.min.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}">

</head>
<body>
     <div id="logo"><img src="{{ url_for('static', filename='img/logo.svg') }}" </div>
     <header class="site-header">
          <nav class="navbar navbar-expand-md navbar-dark bg-steel">
            <div class="container">
              <a class="navbar-brand" href="#">R&S tools</a>
                <div class="navbar-nav mr-auto">
                        <a class="nav-item nav-link" href="{{ url_for('admin.main_menu') }}">Enter site</a>
                </div>
                <!-- Navbar Right Side -->
                <div class="navbar-nav">
                  <a class="navbar-brand" href="#">Welkom {{session.username}}</a>
                  <a class="nav-item nav-link" href="{{ url_for('admin.admin_menu') }}">Admin page</a>
                </div>
            </div>
          </nav>
    </header>
    <div class="container">
        <div class="jumbotron">
            {% if g.breadcrumbs %}
            {% for breadcrumb, breadcrumb_title in g.breadcrumbs|zip(g.breadcrumb_titles) %}
            <a href="{{ breadcrumb }}" >{{ breadcrumb_title  }}</a>
            {% endfor %}
            {% endif %}
            {% for message in get_flashed_messages() %}
            <div class="status">{{ message }}</div>
            {% endfor %}

            {% if error %}
            <div class="error"><strong>Error:</strong> {{ error }}</div>
            {% endif %}

            {% block content %}
            {% endblock %}
        </div>
    </div>
    <!-- scripts -->
    <script src="{{ url_for('static', filename='js/jquery.min.js') }}"></script>
    <script src="{{ url_for('static', filename='js/bootstrap.min.js') }}"></script>
    <script src="{{ url_for('static', filename='js/popper.min.js') }}"></script>
    <script type=text/javascript>
        $(document).ready(function(){
          $(".patient").click(function(){
            $("div").removeClass("hidden");
          });
        });
    </script>
</body>
</html>

 

Er is te zien dat de gebruikersnaam dynamisch weergegeven wordt. Deze informatie wordt uit cookies op de server gehaald. Ook wordt boven de tekst “Voeg een gebruiker toe” een zogenaamde “breadcrumb” weergegeven. Deze kan worden gebruikt om te navigeren tussen verschillende pagina’s van de portal. 

Ook is een HTML file _create_table.html aanwezig waarmee een tabel afgedrukt kan worden.

CSS

In de file /var/www/html/rstools/rstools/static/css/main.css is een deel van de opmaak van de site terug te vinden.

Utilities

Er zijn een aantal utility functies gemaakt die in andere bestanden geïmporteerd worden om zodoende daar gebruikt te worden.

De functies bevinden zich in de directory /var/www/html/rstools/rstools/utils in de file utils.py.  Van de belangrijkste functies is een korte omschrijving gegeven.

Cookie reader

def get_cookie_info():

    cookie_info = defaultdict(dict)

    curr_dir = os.getcwd()
    cookie_dir = '/var/lib/php/session'

    os.chdir(cookie_dir)
    cookie_filenames = [filename for filename in glob('sess_*')]

    for cookie_filename in cookie_filenames:
        ctime = os.path.getctime(cookie_filename)
        try:
            with open(cookie_filename, 'r') as lines:
                for line in lines:
                    if 'loggedIn' not in line:
                        continue
                    username = re.search('username\|s:\d+:\"([A-Za-z0-9]+)\"', line).group(1)
                    # This regex should produce a name, but it does not, therefor the split
                    name = re.search(r';name\|s:\d+:\"(.*)\";', line).group(1).split('"')[0]
                    if cookie_info.get(username) is not None:
                        if ctime > cookie_info[username]['ctime']:
                            cookie_info[username]['ctime'] = ctime
                            cookie_info[username]['name'] = name
                    else:
                        cookie_info[username]['ctime'] = ctime
                        cookie_info[username]['name'] = name
        except:
            pass
    cookie_info[None]['name'] = 'Test user'
    os.chdir(curr_dir)
    return cookie_info


Deze zoekt op de server naar cookies die zijn gezet. Uit de meest recente cookie wordt de ‘username’ (bijvoorbeeld isc78253) gehaald en de bijbehorende naam zoals deze in AD bekend is. De informatie wordt in de vorm van een dictionary teruggegeven door de functie. Deze functie wordt in de admin views.py file gebruik om de gebruikersnaam weer te geven als je op de site komt. 

Scripts_wrapper

def scripts_wrapper(selection, sitename):
    base_dir = '/var/www/html/rstools/rstools'
    if selection == 'lcm_create_scripting_env':
        os.chdir('/var/www/html/rstools/rstools/apps/lcm/scripts_env')
        fmt = 'python3 create_scripting_env.py -S "{}"'.format(sitename)
        cmd = subprocess.getoutput(fmt)
        os.chdir(base_dir)
    elif selection == 'lcm_old_inventory':
        os.chdir(base_dir + '/apps/lcm/sites/' + sitename + '/lcm_env' +  '/ansible/')
        cmd = subprocess.getoutput("ansible-playbook 10-lcm-create-old_inventory.yml")
        os.chdir(base_dir)
<snip>

Met deze functie wordt het mogelijk gemaakt om het resultaat van een Python of Ansible script weer te geven in een tekst box. Hierbij wordt gebruik gemaakt van de getoutput methode van de subprocess module. Tijdens het testen van de applicatie is gebleken dat als een Ansible script waarin interactie met een netwerkelement plaatsvindt door de Linux apache user, dat dan het script er uit klapt met een onduidelijke internal error. Vandaar dat op het laatste moment is besloten om alle interactie met netwerkelementen te vervangen door de Python Netmiko module. 

Breadcrumbs

def create_breadcrumbs(path):
    result = []
    m = re.search('^\/\w+\/\w+', path)
    if m:
        result.append(m.group(0))
    m = re.search('^\/\w+\/\w+\/\w+', path)
    if m:
        result.append(m.group(0))
    m = re.search('^\/\w+\/\w+\/\w+\/\w+', path)
    if m:
        result.append(m.group(0))
    return result


def breadcrumb(view_title):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):

            g.breadcrumbs = create_breadcrumbs('/rstools' + request.path)
            g.breadcrumb_titles = view_title.split(',')

            # Call the view
            route_view = f(*args, **kwargs)

            return route_view
        return decorated_function
    return decorator


Zoals eerder is vermeld, zijn er breadcrumbs aanwezig waarmee door de portal genavigeerd kan worden. Het is belangrijk om te vermelden dat de view_title van de functie even diep moet zijn als de URL van de betreffende pagina. Een voorbeeld uit de views.py file van de LCM app.

@lcm.route('/lcm/prepare_site')
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Voorbereiding Site')
def lcm_prepare_site_main_menu():

De ‘diepte’ van de URL ‘/lcm/prepare_site’ is gelijk aan twee net als de diepte van de breadcrumb 'LCM, -> Voorbereiding Site' . Let bij de breadcrumb op dat elementen gescheiden worden door een komma. Verder valt op dat de breadcrumb functie als zogenaamde decorator gebruikt wordt in een route view. Met zo’n coding construct wordt functionaliteit toegevoegd aan de route view. Verder valt te zien dat er meerdere decorators aanwezig kunnen zijn, die dus elk specifieke functionaliteit toevoegen aan een route view.

Site Authorisatie

def required_access_level(access_level):
    def decorator(func):
        @wraps(func)
        def wrap(*args, **kwargs):
            if access_level not in session.get('user_rolenames'):
                flash('U bent niet geautoriseerd.')
                return redirect(url_for('admin.index'))
            else:
                return func(*args, **kwargs)
        return wrap
    return decorator

Met de bovenstaande functie kan worden afgedwongen dat een eindgebruiker een pagina kan bekijken als een bepaalde userrole aanwezig is bij een user. Er wordt daarbij gebruik gemaakt van het Flask session object. In dit object, wat feitelijk een cookie is, is opgeslagen welke gebruikersrollen er bij een gebruiker horen. Dit object wordt met deze informatie gevuld als de portal wordt opgestart. De gebruikersrollen zijn in dit geval opgeslagen in de dictionary session[‘user_rolenames’]. 
 
Flask blueprints
Zoals eerder is vermeld, maakt de Flask Blueprint feature het mogelijk om verschillende applicaties onder te verdelen in verschillende directories en files. 

/var/www/html/rstools/rstools/apps
[isn78253@isivsx0024 apps]$ ls -la
total 0
drwxr-xr-x 6 rstools root  87 Feb 15 11:59 .
drwxrwxrwx 9 rstools root 214 Feb 23 09:41 ..
drwxr-xr-x 4 rstools root  77 Feb 24 19:37 admin
-rw-r--r-- 1 rstools root   0 Jan 15 06:43 __init__.py
drwxrwxrwx 8 rstools root 124 Feb 24 11:19 lcm
drwxrwxrwx 6 rstools root 100 Feb 23 09:07 port_uptime

In de geel gearceerde directories staan bestanden die bij de applicaties horen. De lege file __init__.py mag niet verwijderd worden. Het doel van deze file is om ervoor te zorgen dat verschillende Python files functies en andere utilities kunnen importeren.

In elk applicatie directory staat een views,py file en een directory templates met HTML templates.

[root@isivsx0024 admin]# pwd
/var/www/html/rstools/rstools/apps/admin
[root@isivsx0024 admin]# ls -la
total 8
drwxr-xr-x 3 rstools root   39 Feb 28 06:49 .
drwxr-xr-x 6 rstools root   87 Feb 15 11:59 ..
drwxr-xr-x 2 rstools root  270 Feb 22 05:56 templates
-rwxrwxrwx 1 rstools root 7086 Feb 27 06:30 views.py


Views en routing

Een voorbeeld van een view is de volgende:

@admin.route('/main_menu')
def main_menu():
    return render_template('main_menu.html')

In het bovenstaande voorbeeld wordt een HTML template main_menu.html gerendered als de functie main_menu wordt aangeroepen. Deze functie bevindt zich in de generieke HTML pagina:

<snip>
<a class="nav-item nav-link" href="{{ url_for('admin.main_menu') }}">Enter site</a>
<snip>

De Flask url_for functie in de HTML code wordt dus gebruik om ervoor te zorgen dat juiste HTML template wordt aangeroepen.

In elke views.py file bevinden zich in de regel een aantal functies die bepaalde zaken doen. Denk hierbij aan het toevoegen van een gebruiker in de database, het uitvoeren van een script,het uploaden van een bestand, etc, etc. In elke view functie gebeurt in principe maar 1 ding. Het is belangrijk om de functienamen, URL namen en bijbehorende HTML template file namen consistent te benoemen. Zodoende blijft het gemakkelijk om de URL’s die de user gebruikt te associëren met de bijbehorende view functies.



Flask session objecten

Met een Flask session object is het mogelijk om global state tussen de view functies te bewaren. In het onderstaande voorbeeld wordt in de eerste view functie  session['inv_created'] gelijk aan True gemaakt als de functie wordt getriggerd door een eindgebruiker. In de tweede functie wordt dit gebruikt om af te dwingen dat dit is gebeurd. In het niet is gebeurd, wordt een error aan de gebruiker gepresenteerd dat er in dit geval eerst een inventory gecreëerd moet worden.

def lcm_create_netmiko_inventory():
    session['inv_created'] = True
<snip>

@lcm.route('/lcm/migrate_site/select_device', methods = ['GET', 'POST'])
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Migratie site, -> Selecteer een device')
def lcm_select_device():
    if session.get('inv_created'):
        <snip>
    else:
        error = 'U moet eerst een inventory maken.'
        current_app.logger.info('User %s forget to create inventory', session['username'])
        return render_template('lcm_main_menu.html', error=error)

 
Templates

In de directory templates zijn HTML templates aanwezig die in de verschillende view functies worden aangeroepen.

Admin portal

In de views.py file die bij het admin gedeelte van de portal hoort, is ook de root URL aanwezig met de bijbehorende functie met naam index. Als er geen cookie informatie wordt gevonden, dan wordt de eindgebruikers geredirect naar een andere portal waar dan vervolgens wel een cookie kan worden gezet die uitgelezen kan worden. In dit cookie is o.a. LDAP informatie aanwezig.

Naast de bovenstaande view functie, zijn er aantal functies aanwezig om eindgebrukers en rollen te kunnen toevoegen, verwijderen en opvragen uit de database.

LCM portal

In de root directory van de LCM portal is een directory aanwezig met Python en Ansible scripts die het uiteindelijke werk doen. 

[root@isivsx0024 scripts_env]# pwd
/var/www/html/rstools/rstools/apps/lcm/scripts_env
[root@isivsx0024 scripts_env]# ls -la
total 20
drwxr-xr-x 7 rstools root  191 Feb 23 07:19 .
drwxrwxrwx 7 rstools root  105 Feb 28 07:40 ..
drwxr-xr-x 6 rstools root 4096 Feb 24 21:06 ansible
drwxr-xr-x 2 rstools root   71 Jan 19 20:14 ansible_inventory_files
-rw-r--r-- 1 rstools root 2466 Feb  8 14:59 config_generator.py
-rw-r--r-- 1 rstools root 4880 Feb 23 07:19 create_inventory.py
-rw-r--r-- 1 rstools root  988 Jan 20 13:19 create_scripting_env.py
drwxr-xr-x 2 rstools root  200 Feb 16 12:17 j2templates
drwxr-xr-x 3 rstools root  134 Feb 14 11:28 python_utils
drwxr-xr-x 3 rstools root  195 Feb 25 10:49 scripts

In de subdirectory ansible zijn een aantal ansible playbooks aanwezig die worden gebruikt. Ook zijn hier een aantal netmiko utilities aanwezig die instaat zijn om configuraties op netwerkelementen te plaatsen of om netwerkinformatie op te kunnen vragen.

Ook is in de root directory een directory “sites” aanwezig. 

[root@isivsx0024 sites]# pwd
/var/www/html/rstools/rstools/apps/lcm/sites
[root@isivsx0024 sites]# ls -la
total 0
drwxrwxrwx 13 rstools root   160 Feb 25 16:17 .
drwxrwxrwx  7 rstools root   105 Feb 28 07:40 ..
drwxr-xr-x  4 apache  apache  36 Feb 23 07:23 ams003
drwxr-xr-x  4 apache  apache  36 Feb 23 08:15 ams005
drwxr-xr-x  4 apache  apache  36 Feb 23 08:20 ams015
drwxrwxrwx  4 apache  apache  36 Feb 21 16:29 ams025
drwxr-xr-x  4 apache  apache  36 Feb 23 08:32 ams031
drwxr-xr-x  4 apache  apache  36 Feb 23 08:42 ams033
drwxr-xr-x  4 apache  apache  36 Feb 23 08:50 ams035
drwxr-xr-x  4 apache  apache  36 Feb 24 10:23 noh075
drwxr-xr-x  4 apache  apache  36 Feb 25 08:03 oon019
drwxr-xr-x  4 apache  apache  36 Feb 26 08:04 oon059
drwxr-xr-x  4 apache  apache  36 Feb 25 16:34 oon181


In elk van de subdirectories wordt een complete set van scripts gekopieerd. Dit maakt het mogelijk dat er parallel door verschillende gebruikers gewerkt kan worden aan verschillende sites. Een bijkomend voordeel is ook dat bugs lokaal opgelost kunnen worden voordat e oplossingen gemerged worden met “root” repository.
 
Onderhoud

Troubleshooting

Als er een fout optreedt in de portal wordt in de regel een volledige stack trace neergezet in de volgende file. Je hebt root rechten nodig om de file te kunnen bekijken.

[root@isivsx0024 sites]# cat  /var/log/httpd/ssl_error_log
[Sun Feb 27 03:21:01.735313 2022] [ssl:warn] [pid 1000668:tid 139782955444544] AH01909: isivsx0024.beheer.local:443:0 server certificate does NOT include an ID which matches the server name
[Mon Feb 28 06:49:07.750482 2022] [ssl:warn] [pid 1000668:tid 139782955444544] AH01909: isivsx0024.beheer.local:443:0 server certificate does NOT include an ID which matches the server name


Activeren nieuwe configuratie

Als een nieuwe configuratie in de portal is gemaakt, bijvoorbeeld een nieuwe functie, dan moet de webserver gereload worden. Dit moet op de volgende manier gebeuren:

[root@isivsx0024 sites]# systemctl reload httpd


Het is overigens niet nodig om te reloaden als wijzigingen zijn aangebracht in LCM backend Python of Ansible scripts.




#######################################################
#######################################################



		
Visie Network Automation
	



	



 






Inhoud
Documentinformatie	2
Inleiding	3
Visie op Network Automation	4
Wat is Network Automation wat levert het op?	5
Hoe te beginnen?	6
Vervolgstappen	7
Wat is er voor nodig?	8
Kennis	8
Organisatie	8
Ontwikkel – en productieomgeving	8













	
Documentinformatie
Versie	Naam	Aanpassing	Datum
0.1	Hans Verkerk / 
Chris van den Brink	Initiele versie	04-12-2020
			
			
			
			
			

Inleiding
We vinden dat we aan een zeer uitdagende opdracht zijn begonnen. We realiseren ons dat er een hoop werk te verzetten is om uiteindelijk tot een deels of volledig geautomatiseerde netwerkomgeving te komen. 

Dit is hoe je een olifant kunt opeten:

Chill out or take a deep breath. Take a deep breath and calm down. At this point, you’re just stressing yourself out needlessly. ...

Step back and get some perspective. Review and clarify the results you’re seeking. Ask yourself: What outcome / goal are you trying to achieve? What does success look like? ...

Start breaking it into small pieces. This is the awesome part because I see all the neat parts that I’ll get to do. ...







Visie op Network Automation
Onze visie is dat m.b.v. Network Automation de politie organisatie, beter dan nu, in staat zal zijn om sneller en minder foutgevoelig en ook efficiënter nieuwe en bestaande netwerk diensten en achterliggende werkzaamheden te kunnen opleveren. 

Onder Automation verstaan we scripting en tooling. 

We zullen hieronder de visie toelichten en ook beschrijven welke stappen hierin genomen kunnen worden.

Wat is Network Automation wat levert het op?
Een definitie van Network Automation is het elimineren van herhaaldelijke en manuele taken of werkzaamheden. 

Het is randvoorwaardelijk dat het proces rondom elke taak inzichtelijk en expliciet wordt gemaakt.
Automation maakt het mogelijk om fouten door menselijk handelen te elimineren. 

Verder kunnen de volgende redenen aangedragen worden om Network Automation te implementeren.

-	Hierdoor kan het risicoprofiel van bijvoorbeeld standaard changes verder verlaagd worden en kunnen daardoor netwerk diensten sneller en efficiënter geleverd worden.

-	Vereenvoudig het netwerk management. Er kunnen bijvoorbeeld op reguliere basis controles uitgevoerd worden om de risico’s op verstoringen en downtime te verminderen.

-	Door repetitieve taken te automatiseren kunnen medewerkers vrijgemaakt worden voor andere werkzaamheden.
Hoe te beginnen?
De politie heeft al ruime ervaring opgedaan met Network Automation middels voornamelijk het HP-NA product. Een belangrijk leerpunt tot zoverre is geweest dat het niet voor alle specifieke behoeften van de politie optimaal is toe te passen.

Onze visie en ervaring is dat elke vorm van Automation, zij het relatief klein, of wat groter waardevol kan zijn binnen een grote IT organisatie. 

Onze ervaring is dat klein beginnen een aantal voordelen biedt, zoals snelle adaptie en flexibiliteit.
Dus anders gezegd: “Go for the low hanging fruits”. 

Een typische benadering hiervan is:

1.	Identificeer een simpel probleem.
2.	Identificeer gemeenschappelijke componenten
3.	Los het probleem op
Een aantal belangrijke voorwaarden is om het niet te ingewikkeld te maken en tot een acceptabele oplossing te komen. Dus vermijd om te beginnen om “corner cases” mee te nemen in de oplossing. 
Vanuit de ervaring die hiermee is opgedaan kunnen vervolgstappen worden gezet. 

.


Vervolgstappen

Een meer generieke aanpak die gehanteerd kan worden in een verder stadium is:

1.	Leer de technologie of een product die nodig is om een probleem op te lossen
2.	Bouw een proof-of-concept
3.	Regel een pilot
4.	Ga in productie


Een aantal overwegingen die gemaakt moeten worden als onder punt 1 besloten wordt om een product aan te schaffen, zijn:

-	Wat kost het product?
-	Welke integratie kosten zijn bovenop de aanschafkosten te verwachten?
-	Kan het product precies wat gewenst is?
-	Hoe uitbreidbaar (qua features) is het product?


En als besloten wordt om functionaliteit in-house te maken:

-	Wordt de keuze gedragen door het management?
-	Zijn er resources beschikbaar om het maken?
-	Kan er klein worden begonnen en gradueel nieuwe features worden toegevoegd?
-	Kan er hulp ingekocht worden (software ontwikkelaars)?


Wat is er voor nodig?
Kennis

Om Automation een succes te laten worden is het van belang, dat de mensen die er actief mee te maken krijgen, voldoende kennis bezitten van scripting talen en uiteraard ook beschikken over voldoende netwerk specifieke kennis. 

Ook is het van belang om leergierig te zijn om nieuwe kennis eigen te maken en uit te willen dragen aan collega medewerkers. Wellicht is het ook wenselijk om gaandeweg externe expertise in te huren. 

Organisatie

Uit onze ervaring is het aan te bevelen om een aantal medewerkers gedeeltelijk of geheel toe te wijzen aan Automation en er zodoende ervaring mee op te laten doen. 
Verder is het belangrijk om de teamleden verantwoordelijk te maken voor het ontwikkelen en operationeel houden van alle Automation producten en scripts. 

In de markt wordt deze manier van werken NetDevOps genoemd. Onder andere Cisco moedigt deze manier van werken aan en beweegt steeds meer deze kant op. Er zijn nu zelfs al certificeringen op dit gebied te behalen.

Het is verder aan te bevelen om “het NetDevOps team” via een scrum/agile methodiek te laten werken. Deze manier van werken is gangbaar in het software ontwikkel werkveld.

Ontwikkel – en productieomgeving

Het is aan te bevelen om een ontwikkelomgeving te hebben waarvan in teamverband gebruik gemaakt kan gaan worden. In deze omgeving is minimaal een IDE (Integrated Development Environment) aanwezig. Ook is ondersteuning om grafisch applicaties te kunnen ontwikkelen wenselijk. 

Uiteraard is het ook van belang om een goede testomgeving tot de beschikking te hebben.
Ook is een productie omgeving nodig om applicaties te kunnen hosten. 


#################################################################
#################################################################



		
LCM configuratie generator

Requirements
	



	



 






Inhoud
Documentinformatie	2
Inleiding	3
Eisen	4
Eindgebruikers ervaring	4
Inventarisatie data huidige site	4
Categoriseren VLAN data van een site	4
Attributen t.b.v. netwerk management en rol van het netwerkelement	5
Attributen van de nieuwe stack configuraties	5
Migratie logica	5













	
Documentinformatie
Versie	Naam	Aanpassing	Datum
0.1	Hans Verkerk 	Initiele versie	25-3-2021
0.2	Hans Verkerk	Review verwerkt 	29-3-2021
0.3	Hans Verkerk	Update	2-9-2021
0.4 	Hans Verkerk	Requirement 6.1 aangepast	20-9-2021
			
			







	
Inleiding
Een belangrijke activiteit van R&S is het life cycle management van netwerk apparatuur op de zogenaamde EGL locaties. 

Dit document beschrijft de functionele eisen en wensen van een op Excel gebaseerde tool (lees: een set van Python scripts) om IOS netwerk configuraties te produceren. De site specifieke data van een eindgebruiker locatie wordt geautomatiseerd overgenomen van de configuraties van de oude apparatuur. De tool maakt het ook mogelijk om consolidatie van apparatuur mogelijk te maken die gedaan wordt in het kader van kostenbesparing. Zo zullen vooral de ‘router’ en ‘switching’ functionaliteit die vaak in de bestaande apparatuur in afzonderlijke netwerk elementen zijn ondergebracht, geconsolideerd worden. De tool maakt het ook mogelijk om Vlan’s uit te faseren.

Dit document is opgesteld na de eerst oplevering van de tool in het voorjaar van 2021. Nog niet alle features die hier zijn beschreven, zullen vanaf het begin zijn geïmplementeerd. De eerste oplevering van de tool zal de LCM migratie van een tiental locaties in en rond Amsterdam faciliteren. Het is te voorzien dat in de loop van de tijd het aantal features zal worden uitgebreid en dat een aantal beschreven features alsnog zal worden geïmplementeerd. Indien een genoemde eis niet of gedeeltelijk is geïmplementeerd, dan zal dit kort worden vermeld.

Eisen
Eindgebruikers ervaring

1.1	De tool moet het mogelijk te maken om in 80% van alle gevallen binnen een uur configuraties voor de nieuwe netwerk elementen van een site te maken, dus zowel preconfiguraties als de uiteindelijke configuraties. De tool voorziet in het kunnen consolideren van netwerk apparatuur om kosten te kunnen besparen. De tool is vooral gericht op het overzetten van laag-2 en laag-3 configuratie data van de bestaande apparatuur naar de nieuwe apparatuur. Het blijft echter te allen tijde noodzakelijk om de oude configuraties te inspecteren om er zeker van te zijn dat mogelijke specials mee gemigreerd worden. De tool ondersteunt dus per definitie niet alle mogelijke migratie scenario’s!

Inventarisatie data huidige site

2.1	Er dienen velden aanwezig te zijn om de afkorting van de naam van de site, de namen van de huidige netwerkelementen en rol van de netwerkelementen (router of switch) in te voeren. Op basis van deze informatie worden de meest recente backups van de netwerkelementen ingelezen. De afkorting van de site wordt gebruikt om data (nieuwe configuraties) in een aparte directory op te slaan.
2.2	De tool moet het mogelijk maken om specifieke data van een huidige site op een overzichtelijk manier in Excel te presenteren. De interface eigenschappen van alle switches op een site moeten in een enkele tab gepresenteerd kunnen worden, zodat met de Excel autofilter feature dwarsdoorsnedes in de data gemaakt kunnen worden.
2.3	De tool moet een lijst van huidige gebruikte Vlans kunnen opleveren. Deze lijst wordt vervolgens gebruikt om een zogenaamde VLAN “van-naar” lijst te maken om aan te geven of Vlans uit gefaseerd kunnen worden.


Categoriseren VLAN data van een site

Het is noodzakelijk om bepaalde data van VLANs van een site in bepaalde categorieën onder te brengen. Het doel hiervan is onder andere om de business logica te kunnen implementeren. De volgende categorieën moeten aangegeven kunnen worden:

1.	Data. Dit zijn VLAN’s waarop standaard apparatuur (PC’s etc.) zijn aangesloten
2.	Confidentiële Data. Dit zijn VLAN’s waarin m.b.v. dot1x geautoriseerde clients aanwezig zijn. 
3.	Voice.
4.	Transit. De zijn VLAN’s waarop verkeer op een WAN koppeling wordt in - en uit gekoppeld.
5.	Management VLAN.
6.	VRF. De naam van een laag-3 VRF waarop een VLAN eventueel is getermineerd.
7.	Base VLAN naam. Dit is de naam van een “legacy” VLAN wat gemigreerd wordt.

3.1	Het kunnen categoriseren van VLAN’s zoals hierboven is beschreven
3.2	Het bepalen van een “best guess” van de categorieën op basis van herkenbare patronen. 
3.3.	Het aanbrengen van user validatie van de data (nog niet geïmplementeerd)







Attributen t.b.v. netwerk management en rol van het netwerkelement

Naast de eerder genoemde configuratie attributen moeten nog een aantal andere attributen kunnen worden toegevoegd:

1.	Naam van elk nieuw netwerkelement
2.	Rol van elk nieuw netwerkelement (router of switch)
3.	Management IP adres, subnet en default gateway.

4.1	Het kunnen opvoeren van de bovenstaande informatie
4.2	Het rapporteren van de huidige management IP informatie, zodat deze mogelijk gekopieerd kan worden
4.3.	Het aanbrengen van user validatie van de data (niet geïmplementeerd)


Attributen van de nieuwe stack configuraties

De volgende informatie over de stacks moet ingevoerd kunnen worden.

1.	Het type netwerkelement en volgnummer in een stack
2.	Het type uplink module van een netwerkelement (optioneel)

5.1	Het kunnen opvoeren van de bovenstaande informatie
5.2	Met de ingevoerde informatie worden lijsten met beschikbare interfaces gegenereerd. Deze lijsten kunnen gebruikt worden bij het samenstellen van migratie “van-naar” tabellen in Excel.
5.3.	Het aanbrengen van user validatie van de data (niet geïmplementeerd)


Migratie logica


6.1 	De ‘afwijkende’ koper (UNI) poorten moeten gemigreerd kunnen worden aan de hand van een “Van-Naar” tabel die door de tool gegenereerd worden. Afwijkend moet geïnterpreteerd worden in de zin dat dit poorten zijn waarop geen standaard werkplekken zijn aangesloten. In de tabel moet de relatie tussen de oude hostname/oude poort en nieuwe hostname/nieuwe poort beschreven. Alle overige standaard poorten hoeven dus niet volgens een 1-op-1 schema overgezet te worden.
6.2	Indien een access poort zich in een data VLAN (zie 3.1) bevindt, wordt deze standaard van een Voice VLAN voorzien in de nieuwe configuratie. De poort wordt m.b.v. een IOS template (ENDUSER of Secured) geïmplementeerd. Dit laatste gebeurt ook als er zowel een data of voice VLAN op de poort aanwezig is. 
6.3	Access poorten in Legacy VLAN’s worden altijd voorzien van een Voice VLAN
6.4	Indien een EGL-B site gemigreerd wordt naar een EGL-B site, dan wordt alle IP informatie 1-op-1 overgenomen van het oude routerende netwerk element.
6.5.	Indien een EGL-C site geconsolideerd wordt naar een EGL-B site, dan worden de HSRP adressen van de laag-3 interfaces van de EGL-C site overgenomen als gateway adressen in het nieuwe netwerkelement met de routerende rol.
6.6 	Indien een EGL-C site gemigreerd wordt naar een EGL-C site, dan wordt de IP informatie 1-op-1 overgenomen. Het eerste routerende element (op basis van volgnummer in de hostname) wordt als spanning-tree root en HSRP active machine voor alle VLAN’s ingericht.
6.7	Alle nieuwe poorten worden voorzien van een default auto negotiation configuratie. 
6.8 	Er wordt een lijst beschikbaar gemaakt van nieuwe poorten die met een duplex of speed instelling zijn gemigreerd. Dit maakt het mogelijk om tijdens een migratie te controleren of de poorten met de nieuwe auto negotiation instelling overweg kunnen.
6.9	Op alle switches worden templates geplaatst met identieke namen (dus ENDUSER of Secured) ondanks dat in de templates op verschillende switches verschillende access VLAN’s kunnen worden gebruikt.
6.10	Indien als gevolg van de “van-naar” poort mapping meerdere data VLAN’s uitkomen op een nieuw netwerk element zal het script een warning genereren en het data VLAN in de betreffende templates (ENDUSER en/of Secured) niet configureren. Het script genereert een foutmelding. Na de foutmelding moet voor de gehele site in een aparte tabel aangegeven worden welk data VLAN gekoppeld wordt aan welke access switch en moet het script opnieuw worden uitgevoerd.
6.11	Indien een site wordt gemigreerd waar dot1x is geactiveerd, zal de mapping van alle data VLANs naar de confi VLAN’s  in een aparte tabel geconfigureerd moeten worden. Indien het script detecteert dat dot1x op de huidige site aanwezig is, wordt een foutmelding gepresenteerd en moet de tabel dus gevuld worden. 
6.12	Een description van een switchpoort wordt alleen overgenomen als deze maximaal drie maal uniek op een poort voorkomt op alle switchpoorten. Hiermee wordt voorkomen dat onnodig geachte descriptions op de standaard werkplekpoorten worden overgenomen. Er wordt hierop een uitzondering bijgehouden voor devices waarvan de informatie zinvol wordt geacht, zoals DECT telefoons, etc (whitelists). Ook is het mogelijk om z.g. blacklists te creëren. 
6.13	Indien een SVI geen IP adres wordt de configuratie overgenomen als het VLAN op de nominatie staat om gemigreerd te worden. Het gevolg is wel dat in de VLAN description de subnet informatie niet opgenomen kan worden --> Verwijderen SVI. --> Controleren platte VLAN’s 
6.14	Indien 1 of meerdere data VLAN’s zich niet in de standaard VLAN range bevinden, dan zal het script migratie configuratie snippets aanleveren om deze aan het einde om te nummeren (Requirement afvoeren. Komt niet in tool, maar moet in Ansible komen.)
6.15	De poorten van glas koppelingen tussen netwerk elementen worden automatisch toegewezen door het script en voorzien van een correcte description.
6.16	VLAN’s op trunk verbindingen tussen netwerkelementen worden automatisch gepruned ‘naar behoefte’.
6.17	VLAN’s op verbindingen naar KPN of MAN koppelingen worden niet overgenomen uit de oude configuraties (m.b.t. pruning). De pruning wordt berekend op basis van de VLAN categorisaties.
6.18	DHCP relay adressen worden uit de huidige configuratie overgenomen.
6.19	Bij een incorrecte naamgeving van netwerkelementen wordt een warning gegeven (niet geïmplementeerd)
6.20	Alle warnings uit het script worden in een aparte tab van de sheet afgeprint (niet geïmplementeerd)
6.21	De volgende settings van MAN/KPN interfaces worden 1-op-1 overgenomen: speed, duplex, bandwidth, description. VLan pruning wordt berekend.
6.22	UNI poorten die op de oude apparatuur niet zijn geconfigureerd worden op de nieuwe apparatuur voorzien van een standaard configuratie (dus met ENDUSER of Secured template). De poorten worden open gezet.
6.23 	Niet gebruikte NNI poorten worden dichtgezet en in layer-3 mode gezet.
6.24	DHCP snooping wordt alleen op VLAN’s geactiveerd als er op de SVI interface(s) 1 of meerdere helper adressen aanwezig zijn.
6.25	uRPF wordt op alle VLAN’s geactiveerd, behalve op het management en op transit VLAN’s.
6.26	De meest recente versie van de design templates wordt gebruikt om configuraties van de nieuwe netwerkelementen samen te stellen.
6.27	VLAN3 die in veel bestaande netwerkelementen wordt gebruikt, wordt niet gemigreerd.
6.28 	De laatste versie van het naamgevings document van Hans Kooij is gebruikt om bij het bepalen van VRF namen, descriptions, etc.
6.29	UNI Poorten die geshut zijn met een configuratie worden niet 1-op-1 overgenomen, omdat deze poorten open worden gezet.
6.30 	Statische routes worden alleen overgenomen indien de next-hop valt in een directly connected netwerk.
6.31	SNMP location strings uit de bestaande switches worden in een aparte tab afgedrukt, zodat deze gekopieerd kunnen worden naar een string die bij een nieuw netwerkelement hoort. 
6.32	Het script ondersteunt geen secundaire IP adressen.



########################################
########################################

[isn78253@isivsx0024 rstools]$ cat config.py
import os


class Config:

    basedir = os.path.abspath(os.path.dirname(__file__))

    DEBUG = True
    TESTING = False
    CSRF_ENABLED = True
    SECRET_KEY = '57e19ea558d4967a552d03deece34a70'

    DATABASE = 'rstools.db'
    DATABASE_PATH = os.path.join(basedir, DATABASE)

    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SQLALCHEMY_DATABASE_URI = 'sqlite:///' + 'rstools.db'


[isn78253@isivsx0024 rstools]$ cat db_create.py
from models import UserRole, User, engine, Base, Session
#from utils.utils import session_scope

if __name__ == '__main__':

    Base.metadata.drop_all(engine)
    Base.metadata.create_all(engine)
    session = Session()

    userrole = UserRole(name='admin')
    user = User(name='ISC78253')
    userrole.users.append(user)
    session.add(userrole)
    session.add(user)

    userrole = UserRole(name='lcm_user')
    session.add(userrole)

    userrole = UserRole(name='lcm_admin')
    session.add(userrole)
    user = User(name='ISC05561')
    session.add(user)
    session.commit()
    session.close()



[isn78253@isivsx0024 rstools]$ cat forms.py
from flask_wtf import FlaskForm
from wtforms import StringField, DateField, IntegerField, \
    SelectField, PasswordField, TimeField
from wtforms.validators import InputRequired, DataRequired, Length, EqualTo


class LoginForm(FlaskForm):
    username = StringField(
        'Username',
        validators=[DataRequired()])
    password = PasswordField(
        'Password',
        validators=[DataRequired(), Length(min=4, max=40, message='min 4, max 40 chars')])
    confirm = PasswordField(
        'Confirm password',
        validators=[DataRequired(), EqualTo('password', message='Passwords must match')])


class AddUserForm(FlaskForm):
    username = StringField('Gebruikersnaam')
    userrole = SelectField('Gebruikersrol', choices = [])


class DeleteUserForm(FlaskForm):
    username = SelectField('Gebruikersnaam', choices = [])


class AddUserRoleForm(FlaskForm):
    userrole = StringField('Gebrukersrol')


class DeleteUserRoleForm(FlaskForm):
    userrole = SelectField('Gebruikersrol', choices = [])


class AddUserAuthForm(FlaskForm):
    username = SelectField('Gebruikersnaam', choices = [])
    userrole = SelectField('Gebruikersrol', choices = [])


class DeleteUserAuthForm(FlaskForm):
    username = SelectField('Gebruikersnaam', choices = [])
    userrole = SelectField('Gebruikersrol', choices = [])


class SelectNetworkElement(FlaskForm):
    devicename = SelectField('Devicenaam', choices = [])
    ipaddress = SelectField('IPAdres', choices = [])


class SelectFileName(FlaskForm):
    filename = SelectField('File naam', choices = [])

class AddSiteForm(FlaskForm):
    sitename = StringField('SiteNaam')

class DeleteSiteForm(FlaskForm):
    sitename = SelectField('SiteNaam', choices = [])

class EnterSwitchInfo(FlaskForm):
    switchname = StringField(
        'Switch naam',
         validators=[DataRequired()])
    username = StringField(
        'ISN account',
        validators=[DataRequired()])
    password = PasswordField(
        'Wachtwoord digipas',
        validators=[DataRequired()])
    week_criterium = StringField(
        'Week criterium',
         validators=[DataRequired()])


class SelectSiteForm(FlaskForm):
    sitename = SelectField(
        'SiteNaam',
        validators=[InputRequired()],
        choices = [],
    )



[isn78253@isivsx0024 css]$ cat main.css
body {
  background: #fafafa;
  color: #222222;
}

a {
  color:  hsl(207.69, 100%, 25.5%);
}

h1, h2, h3, h4, h5, h6 {
  color: #444444;
}

ul {
  margin: 0;
}

.bg-steel {
  background-color: hsl(207.69, 100%, 25.5%);
}

.site-header .navbar-nav .nav-link {
  color: #cbd5db;
}

.site-header .navbar-nav .nav-link:hover {
  color: #ffffff;
}

.site-header .navbar-nav .nav-link.active {
  font-weight: 500;
}

.content-section {
  background: #ffffff;
  padding: 10px 20px;
  border: 1px solid #dddddd;
  border-radius: 3px;
  margin-bottom: 20px;
}

.error {
    color: red;
    font-size: 1.2em;
}

.status {
    color: green;
    font-size: 1.2em;
}

.scrollable {
  height: 15cm;
  width: 25cm;
  overflow-y: scroll;
}

.hidden {
  display: none;
}

#logo img{
  display: block;
  margin: 0 auto;
  width: 10cm;
  height: 4.5cm;
}

#colheader {
  color: #ffffff;
}
[isn78253@isivsx0024 css]$




[isn78253@isivsx0024 templates]$ cat _create_table.html
{% macro create_table(result) %}
<table class="table">
    <thead class="bg-steel">
    <tr>
        {% for row in result %}
          {% if loop.index == 1 %}
            {% for col_header in row %}
            <th scope="col" id="colheader">{{col_header}}</th>
            {% endfor %}
          {% endif %}
        {% endfor %}
    </tr>
    </thead>
    {% for row in result %}
    <tr>
        {% for value in row.values() %}
        <td>{{ value }}</td>
        {% endfor %}
    </tr>
    {% endfor %}
</table>
{% endmacro %}




isn78253@isivsx0024 admin]$ cat views.py
import sys
from flask import Blueprint, render_template, request, session, current_app, url_for
from flask import redirect, flash
from utils.utils import get_cookie_info, required_access_level, breadcrumb, session_scope
from models import User, UserRole
from forms import LoginForm, AddUserForm, AddUserAuthForm, DeleteUserForm, AddUserRoleForm
from forms import DeleteUserRoleForm, DeleteUserAuthForm


admin = Blueprint('admin', __name__, template_folder='templates')

@admin.route('/')
def index():
    raw_remote_user = request.environ.get('REMOTE_USER')
    session['shortname'] = raw_remote_user.split('@')[0] if raw_remote_user else None
    cookie_info = get_cookie_info()
    if not cookie_info[session['shortname']].get('name'):
        return redirect("https://netwerktools.politie.local?rstools_redirect=true")
    session['username'] = cookie_info[session['shortname']]['name']

    with session_scope() as s:
        users_from_db = s.query(User).all()
        usernames_from_db = [user_from_db.name.upper() for user_from_db in users_from_db]
        if session['shortname'].upper() not in usernames_from_db:
            session['user_rolenames'] = ['default_userrole']
        else:
            user = s.query(User).filter_by(name=session['shortname'].upper()).first()
            userroles = s.query(UserRole).filter(UserRole.users.any(id=user.id)).all()
            user_rolenames = [userrole.name for userrole in userroles]
            session['user_rolenames'] = user_rolenames

    return render_template('index.html')


@admin.route('/main_menu')
def main_menu():
    return render_template('main_menu.html')


@admin.route('/admin')
@required_access_level('admin')
@breadcrumb('Admin')
def admin_menu():
    return render_template('admin_menu.html')


@admin.route('/admin/add_user/', methods=['GET', 'POST'])
@required_access_level('admin')
@breadcrumb('Admin, -> Gebruiker toevoegen')
def add_user():
    form = AddUserForm(request.form)
    with session_scope() as s:
        form.userrole.choices = [userrole.name for userrole in s.query(UserRole).all()]
        if request.method == 'POST':
            if form.validate_on_submit():
                user = User(name=request.form['username'])
                s.add(user)
                userrole = s.query(UserRole).filter(UserRole.name==request.form['userrole']).first()
                userrole.users.append(user)
    current_app.logger.info('User %s added a new user', session['username'])
    return render_template('add_user.html', form=form)


@admin.route('/admin/delete_user/', methods=['GET', 'POST'])
@required_access_level('admin')
@breadcrumb('Admin, -> Gebruiker verwijderen')
def delete_user():
    form = DeleteUserForm(request.form)
    with session_scope() as s:
        form.username.choices = [user.name for user in s.query(User).all()]
        if request.method == 'POST':
            if form.validate_on_submit():
                user = s.query(User).filter(User.name==request.form['username']).first()
                s.delete(user)
    current_app.logger.info('User %s deleted a user', session['username'])
    return render_template('delete_user.html', form=form)


@admin.route('/admin/add_userrole/', methods=['GET', 'POST'])
@required_access_level('admin')
@breadcrumb('Admin, -> Gebruikersrol toevoegen')
def add_userrole():
    form = AddUserRoleForm(request.form)
    with session_scope() as s:
        if request.method == 'POST':
            if form.validate_on_submit():
                userrole = UserRole(name=request.form['userrole'])
                s.add(userrole)
    current_app.logger.info('User %s added a new userrole', session['username'])
    return render_template('add_userrole.html', form=form)


@admin.route('/admin/delete_userrole/', methods=['GET', 'POST'])
@required_access_level('admin')
@breadcrumb('Admin, -> Gebruikersrol verwijderen')
def delete_userrole():
    form = DeleteUserRoleForm(request.form)
    with session_scope() as s:
        form.userrole.choices = [userrole.name for userrole in s.query(UserRole).all()]
        if request.method == 'POST':
            if form.validate_on_submit():
                userrolename = s.query(UserRole).filter(UserRole.name==request.form['userrole']).first()
                s.delete(userrolename)
    current_app.logger.info('User %s deleted a userrole', session['username'])
    return render_template('delete_userrole.html', form=form)


@admin.route('/admin/add_user_auth/', methods=['GET', 'POST'])
@required_access_level('admin')
@breadcrumb('Admin, -> Gebruikers authorisatie toevoegen')
def add_user_auth():
    form = AddUserAuthForm(request.form)
    with session_scope() as s:
        form.username.choices = [user.name for user in s.query(User).all()]
        form.userrole.choices = [userrole.name for userrole in s.query(UserRole).all()]
        if request.method == 'POST':
            if form.validate_on_submit():
                user = s.query(User).filter(User.name==request.form['username']).first()
                userrole = s.query(UserRole).filter(UserRole.name==request.form['userrole']).first()
                userrole.users.append(user)
    current_app.logger.info('User %s added authorization to a user', session['username'])
    return render_template('add_user_auth.html', form=form)


@admin.route('/admin/get_users', methods=['GET', 'POST'])
@required_access_level('admin')
@breadcrumb('Admin, -> Gebruikers opvragen')
def get_users():
    result = []
    with session_scope() as s:
        for user in s.query(User).all():
            userroles = s.query(UserRole).filter(UserRole.users.any(id=user.id)).all()
            user_rolenames = [userrole.name for userrole in userroles]
            row = {'Gebruikers': user.name, 'Gebruikersrollen': ','.join(user_rolenames)}
            result.append(row)
    return render_template('get_users.html', result=result)


@admin.route('/admin/delete_user_auth/', methods=['GET', 'POST'])
@required_access_level('admin')
@breadcrumb('Admin, -> Verwijderen gebruikers authorisatie')
def delete_user_auth():
    form = DeleteUserAuthForm(request.form)
    with session_scope() as s:
        form.username.choices = [user.name for user in s.query(User).all()]
        form.userrole.choices = [userrole.name for userrole in s.query(UserRole).all()]
        if request.method == 'POST':
            if form.validate_on_submit():
                user = s.query(User).filter(User.name==request.form['username']).first()
                userrole = s.query(UserRole).filter(UserRole.name==request.form['userrole']).first()
                userrole.users.remove(user)
    return render_template('delete_user_auth.html', form=form)


@admin.route('/admin/get_userroles', methods=['GET', 'POST'])
@required_access_level('admin')
@breadcrumb('Admin, -> Gebruikersrollen opvragen')
def get_userroles():
    result = []
    with session_scope() as s:
        for userrole in s.query(UserRole).all():
            row = {'Gebruikersrol': userrole.name}
            result.append(row)
    return render_template('get_userroles.html', result=result)




[isn78253@isivsx0024 templates]$ cat *.html
{% extends "_base.html" %}
{% block content %}

<h1>Voeg een authorizatie toe aan een gebruiker.</h1>
<br>

<form method="post" action="/rstools/admin/add_user_auth/">
    {{ form.csrf_token }}
    <div>
        {{ form.username.label }}
        <div>
            {{ form.username }}
        </div>
    </div>
    <br>
    <div>
        {{ form.userrole.label }}
        <div>
            {{ form.userrole }}
        </div>
    </div>
    <br>
    <div>
        <button class="btn btn-sm btn-success bg-steel" type="OK">OK</button>
    </div>
</form>

{% endblock %}
{% extends "_base.html" %}
{% block content %}

<h1>Voeg een gebruiker toe.</h1>
<br>

<form method="post" action="/rstools/admin/add_user/">
    {{ form.csrf_token }}
    <div>
        {{ form.username.label(class_="test") }}
        <div>
            {{ form.username }}
        </div>
    </div>
    <br>
    <div>
        {{ form.userrole.label }}
        <div>
            {{ form.userrole }}
        </div>
    </div>
    <br>
    <div>
        <button class="btn btn-sm btn-success bg-steel" type="log in">OK</button>
    </div>
</form>

{% endblock %}

{% extends "_base.html" %}
{% block content %}

<h1>Voeg een gebruikersrol toe.</h1>
<br>

<form method="post" action="/rstools/admin/add_userrole/">
    {{ form.csrf_token }}
    <div>
        {{ form.userrole.label(class_="test") }}
        <div>
            {{ form.userrole }}
        </div>
    </div>
    <br>
    <div>
        <button class="btn btn-sm btn-success bg-steel" type="log in">OK</button>
    </div>
</form>

{% endblock %}

{% extends "_base.html" %}
{% block content %}

<h1>Welkom in het admin menu.</h1>
<br>
<br>
<h3>Maak een keuze:</h3>

<div>
        <a href=" {{ url_for('admin.get_users') }} ">Overzicht van gebruikers</a>
</div>

<div>
  <a href=" {{ url_for('admin.get_userroles') }} ">Overzicht van gebruikersrollen</a>
</div>

<br>

<div>
        <a href=" {{ url_for('admin.add_user') }}">Toevoegen van een gebruiker</a>
</div>

<div>
  <a href=" {{ url_for('admin.add_userrole') }}">Toevoegen van een gebruikersrol</a>
</div>

<div>
  <a href="{{ url_for('admin.add_user_auth') }}">Rechten toevoegen aan een gebruiker</a>
</div>

<div>
        <a href="{{ url_for('admin.delete_user_auth') }}">Rechten verwijderen van een gebruiker</a>
</div>

<br>

<div>
  <a href=" {{ url_for('admin.delete_user') }}">Verwijderen van een gebruiker</a>
</div>

<div>
  <a href=" {{ url_for('admin.delete_userrole') }}">Verwijderen van een gebruikersrol</a>
</div>

{% endblock %}
{% extends "_base.html" %}
{% block content %}

<h1>Verwijder een authorizatie van een gebruiker.</h1>
<br>

<form method="post" action="/rstools/admin/delete_user_auth/">
    {{ form.csrf_token }}
    <div>
        {{ form.username.label }}
        <div>
            {{ form.username }}
        </div>
    </div>
    <br>
    <div>
        {{ form.userrole.label }}
        <div>
            {{ form.userrole }}
        </div>
    </div>
    <br>
    <div>
        <button class="btn btn-sm btn-success bg-steel" type="OK">OK</button>
    </div>
</form>

{% endblock %}
{% extends "_base.html" %}
{% block content %}

<h1>Verwijder een gebruiker.</h1>
<br>

<form method="post" action="/rstools/admin/delete_user/">
    {{ form.csrf_token }}
    <div>
        {{ form.username.label }}
        <div>
            {{ form.username }}
        </div>
    </div>
    <br>
    <div>
        <button class="btn btn-sm btn-success bg-steel" type="OK">OK</button>
    </div>
</form>

{% endblock %}
{% extends "_base.html" %}
{% block content %}

<h1>Verwijder een gebruikersrol.</h1>
<br>

<form method="post" action="/rstools/admin/delete_userrole/">
    {{ form.csrf_token }}
    <div>
        {{ form.userrole.label }}
        <div>
            {{ form.userrole }}
        </div>
    </div>
    <br>
    <div>
        <button class="btn btn-sm btn-success bg-steel" type="OK">OK</button>
    </div>
</form>

{% endblock %}
{% extends "_base.html" %}
{% block content %}

{% from "_create_table.html" import create_table %}
<h1>Overzicht van alle gebruikersrollen</h1>
<br>

{{ create_table(result) }}
{% endblock %}

{% extends "_base.html" %}
{% block content %}

{% from "_create_table.html" import create_table %}
<h1>Overzicht van alle gebruikers</h1>
<br>

{{ create_table(result) }}
{% endblock %}

{% extends "_base.html" %}
{% block content %}

{% endblock %}

{% extends "_base.html" %}
{% block content %}

<h1>Welkom in het hoofdmenu.</h1>
<br>
<br>
<h3>Maak een keuze:</h3>
<div>
        <a href="{{ url_for('lcm.lcm_main_menu') }}">LCM app</a>
</div>

<div>
  <a href="{{ url_for('port_uptime.port_uptime_main_menu') }}">Poort gebruik app</a>
</div>


{% endblock %}









[isn78253@isivsx0024 port_uptime]$ cat views.py
import os
import subprocess
from flask import Blueprint, render_template, request, session, current_app, url_for
from flask import redirect, flash
from utils.utils import breadcrumb
from forms import EnterSwitchInfo


port_uptime = Blueprint('port_uptime', __name__, template_folder='templates')


@port_uptime.route('/port_uptime')
def port_uptime_main_menu():
    current_app.logger.info('User %s entered the port uptime main site', session['username'])
    return render_template('port_uptime_main_menu.html')


@port_uptime.route('/port_uptime/enter_switch_credentials', methods = ['GET', 'POST'])
@breadcrumb('PoortUptime, -> Voer switch gegevens in')
def port_uptime_enter_switch_credentials():
    form = EnterSwitchInfo(request.form)
    if request.method == 'POST':
        if form.validate_on_submit():
            session['switchname'] = request.form['switchname']
            session['isn_name'] = request.form['username']
            session['password'] = request.form['password']
            session['week_criterium'] = request.form['week_criterium']
            session['filled_in'] = True
    return render_template('port_uptime_enter_switch_credentials.html', form=form)


@port_uptime.route('/port_uptime/run_script')
def port_uptime_run_script():
    if session.get('filled_in'):
        session['filled_in'] = False
        switchname = session['switchname']
        username = session['isn_name']
        password = session['password']
        week_criterium = session['week_criterium']
        os.chdir('/var/www/html/rstools/rstools/apps/port_uptime/scripts')
        os.system('python3 create_scripting_env.py -U {}'.format(username))
        os.chdir('/var/www/html/rstools/rstools/apps/port_uptime/script_environments/' + username)
        fmt = 'python3 port_uptime.py -u {} -p {} -s {} -w {}'.format(username, password, switchname, week_criterium)
        text =  subprocess.getoutput(fmt).splitlines()
        if 'pyats' in text[0]: # remove first line if it contains pyats
            del text[0]
        text = "\n".join(text)
        current_app.logger.info('User %s executed the port uptime script', session['username'])
    else:
        error = 'U moet eerst het web formulier invullen'
        current_app.logger.info('User %s forget to fill in the port uptime web form', session['username'])
        return render_template('port_uptime_main_menu.html', error=error)
    return render_template('port_uptime_script.html', text=text, page='port_uptime.port_uptime_main_menu')
[isn78253@isivsx0024 port_uptime]$




[isn78253@isivsx0024 scripts]$ cat port_uptime.py
import re
import json
import argparse
from glob import glob
from netmiko import ConnectHandler


class ReSearcher():

    """
    Helper  to enable evaluation
    and regex formatting in a single line
    """

    match = None

    def __call__(self, pattern, string):
        self.match = re.search(pattern, string)
        return self.match

    def __getattr__(self, name):
        return getattr(self.match, name)


class Tree(dict):

    """ Autovivificious dictionary """
    def __missing__(self, key):
        value = self[key] = type(self)()
        return value

    def __str__(self):
        """ Serialize dictionary to JSON formatted string with indents """
        return json.dumps(self, indent=4)


class NetmikoConnector:
    """ Class for device connectivity with IOS switches"""

    def __init__(self, credentials):
        self.credentials = credentials

    def execute_cmds_on_host(self, host, commands):

        output, result = '', None
        device = {'username': self.credentials['username'],
                  'password': self.credentials['password'],
                  'device_type': 'cisco_ios',
                  'host': host
        }
        try:
            with ConnectHandler(**device) as session:
                for command in commands:
                    result = session.send_command(command)
                    output += result
        except Exception as e:
            output += '\nERROR: ' + str(e)
            raise
        return output


def parse_args():
    parser = argparse.ArgumentParser(
        description="Port uptime script"
    )
    parser.add_argument("-u", help="username")
    parser.add_argument("-p", help="password")
    parser.add_argument("-s", help="switchname")
    parser.add_argument("-w", help="week_criterium")
    return parser.parse_args()


def parse_file(filename):

    """ Parses information from 'show interfaces' command and from commands
        to get uptime of all stackmembers
    """

    with open(filename, 'r') as lines:

        parsed_info = Tree()
        match = ReSearcher()
        stackmember = 1

        for line in lines:

            if match(r'^hostname (.*)', line):
                hostname = format(match.group(1))

            if match(r'(\S+).*line protocol.*', line):
                port = format(match.group(1))
                parsed_info[hostname]['portinfo'][port] = [] # input and output in list

            if match(r'^  Last input ([0-9:ywd]+).*', line):
                last_time = format(match.group(1))
                parsed_info[hostname]['portinfo'][port].append(last_time)

            if match(r'^  Last input never.*', line):
                parsed_info[hostname]['portinfo'][port].append('never')

            if match(r'^  Last input .*, output ([0-9:ywd]+)', line):
                last_time = format(match.group(1))
                parsed_info[hostname]['portinfo'][port].append(last_time)

            if match(r'^  Last input .*, output never', line):
                parsed_info[hostname]['portinfo'][port].append('never')

            if match(r'uptime is (.*)', line):
                parsed_info[hostname]['stackinfo'][stackmember] = format(match.group(1))
                stackmember += 1

            if match(r'Switch Uptime[ ]{1,}: (.*)', line):
                parsed_info[hostname]['stackinfo'][stackmember] = format(match.group(1))
                stackmember += 1

            if match(r'Switch uptime[ ]{1,}: (.*)', line):
                parsed_info[hostname]['stackinfo'][stackmember] = format(match.group(1))
                stackmember += 1

    return parsed_info


def time_criterium_check(string, week_criterium='26'):

    """ Returns True if time representation of string is greater
        than specified in week_criterium function parameter
    """

    match = ReSearcher()

    if 'years' in string or 'year' in string:
        return True

    if 'y' in string and not ('day' in string or 'days' in string):
        return True

    if match(r'(\d+)w.*', string):
        return True if int(match.group(1)) >= int(week_criterium) else False

    if match(r'(\d+) weeks', string):
        return True if int(match.group(1)) >= int(week_criterium) else False

    if match(r'[0-9:]+', string):
        return False

    if string == 'never':
        return True

    return False


def process_info(parsed_info, week_criterium='26'):

    """
    Information from parser is evaluated. Result is printed.
    """

    result = Tree()
    match = ReSearcher()

    for switchname in parsed_info:

        used_ports = 0
        unused_ports = 0
        stackmembers_uptime = {}
        stackmembers_criteria = {}

        for stack, items in parsed_info[switchname]['stackinfo'].items():
            stackmembers_uptime[stack] = items
            stackmembers_criteria[stack] = time_criterium_check(items, week_criterium)

        for port, items in parsed_info[switchname]['portinfo'].items():

            if match(r'\w+Ethernet(\d).*', port):
                stackno = format(match.group(1))
                if stackno == '0': # Mgmt port
                    continue
                if not stackmembers_criteria[int(stackno)]:
                    result[switchname][port] = 'used'
                else:
                    input_time_criteria = time_criterium_check(items[0])
                    output_time_criteria = time_criterium_check(items[1])

                    if input_time_criteria and output_time_criteria:
                        unused_ports += 1
                        result[switchname][port] = 'unused'
                    else:
                        used_ports += 1
                        result[switchname][port] = 'used'

        print('Report for switch: ' + switchname)
        print('The time criterium is {} weeks'.format(week_criterium))
        for stackmember in stackmembers_uptime:
            print('The uptime of stackmember {} is {}'.format(stackmember, stackmembers_uptime[stackmember]))
        print('Total number of ports: ' + str(used_ports + unused_ports))
        print('Used ports: ' + str(used_ports))
        print('Unused ports: ' + str(unused_ports))
        print('\n')

    for switchname in result:
        for port, items in result[switchname].items():
            print('{};{};{}'.format(switchname, port, items))

def main():

    args = parse_args()

    username = args.u
    password = args.p
    switchname = args.s
    week_criterium = args.w

    credentials = {'username': username, 'password': password}
    commands = ['show start | i hostname', 'show version', 'show interfaces']

    netmiko = NetmikoConnector(credentials)
    output = netmiko.execute_cmds_on_host(switchname, commands)

    with open('output.log', 'w') as f:
        print(output, file=f)

    parsed_info = parse_file('output.log')
    process_info(parsed_info, week_criterium)

if __name__ == '__main__':
    main()






[isn78253@isivsx0024 templates]$ cat *.html
{% extends "_base.html" %}
{% block content %}

<h1>Voer de switch gegevens in.</h1>
<br>

<form method="post" action="/rstools/port_uptime/enter_switch_credentials">
    {{ form.csrf_token }}
    <div>
        {{ form.switchname.label }}
        <div>
            {{ form.switchname }}
        </div>
    </div>
    <br>
    <div>
        {{ form.username.label }}
        <div>
            {{ form.username }}
        </div>
    </div>
    <br>
    <div>
        {{ form.password.label }}
        <div>
            {{ form.password }}
        </div>
    </div>
    <br>
    <div>
        {{ form.week_criterium.label }}
        <div>
            {{ form.week_criterium }}
        </div>
    </div>
    <br>
    <div>
        <button class="btn btn-sm btn-success bg-steel" type="log in">OK</button>
    </div>
</form>

{% endblock %}

{% extends "_base.html" %}
{% block content %}

<h1>Welkom in het switchpoort gebruik hoofdmenu.</h1>
<br>
<br>
<h3>Maak een keuze:</h3>

<div>
    <a href="{{ url_for('port_uptime.port_uptime_enter_switch_credentials') }}">Voer gegevens in</a>
</div>

<div>
    <a href="{{ url_for('port_uptime.port_uptime_run_script') }}">Voer het script uit</a>
</div>

{% endblock %}

{% extends "_base.html" %}
{% block content %}

<h1>Script resultaat</h1>
<br>
    <textarea class="scrollable">
    {{ text }}
    </textarea>
<div>
        <a href="{{ url_for(page) }}" class="btn btn-info bg-steel" role="button">Ga verder</a>
</div>

{% endblock %}
[isn78253@isivsx0024 templates]$









[isn78253@isivsx0024 lcm]$ cat views.py
import os
import time
import json
import zipfile
import logging
import subprocess
from glob import glob
from flask import Blueprint, render_template, request, session, current_app, url_for
from flask import redirect, flash, send_file
from utils.utils import get_cookie_info, required_access_level, flash_errors, breadcrumb
from utils.utils import scripts_wrapper, session_scope
from models import User, UserRole, Site
from forms import AddSiteForm, SelectSiteForm, DeleteSiteForm, SelectNetworkElement, SelectFileName
from werkzeug.utils import secure_filename


lcm = Blueprint('lcm', __name__, template_folder='templates')


@lcm.route('/lcm')
@required_access_level('lcm_user')
@breadcrumb('LCM')
def lcm_main_menu():
    return render_template('lcm_main_menu.html')


@lcm.route('/lcm/site_mgmt')
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Site management')
def lcm_site_mgmt_main_menu():
    current_app.logger.info('User %s selected Site management main site ', session['username'])
    return render_template('lcm_site_mgmt_main_menu.html')


@lcm.route('/lcm/prepare_site')
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Voorbereiding Site')
def lcm_prepare_site_main_menu():
    current_app.logger.info('User %s selected Preparation of a Site', session['username'])
    if session.get('sitename_select'):
        return render_template('lcm_prepare_site_main_menu.html')
    else:
        error = 'U moet eerst een site selecteren'
        current_app.logger.info('User %s forget to select site', session['username'])
        return render_template('lcm_site_mgmt_main_menu.html', error=error)


@lcm.route('/lcm/migrate_site')
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Migratie Site')
def lcm_migrate_site_main_menu():
    current_app.logger.info('User %s selected Migration of a Site', session['username'])
    if session.get('sitename_select'):
        return render_template('lcm_migrate_site_main_menu.html')
    else:
        error = 'U moet eerst een site selecteren'
        current_app.logger.info('User %s forget to select site', session['username'])
        return render_template('lcm_site_mgmt_main_menu.html', error=error)


@lcm.route('/lcm/site_mgmt/add_site', methods=['GET', 'POST'])
@required_access_level('lcm_admin')
@breadcrumb('LCM, -> Site management, -> Toevoegen site')
def lcm_add_site():
    with session_scope() as s:
        form = AddSiteForm(request.form)
        if request.method == 'POST':
            if form.validate_on_submit():
                site = Site(name=request.form['sitename'])
                s.add(site)
    current_app.logger.info('User %s added a new site', session['username'])
    return render_template('lcm_add_site.html', form=form)


@lcm.route('/lcm/site_mgmt/delete_site', methods=['GET', 'POST'])
@required_access_level('lcm_admin')
@breadcrumb('LCM, -> Site management, -> Verwijderen site')
def lcm_delete_site():
    form = DeleteSiteForm(request.form)
    with session_scope() as s:
        sitenames = [site.name for site in s.query(Site).all()]
        form.sitename.choices = sorted(sitenames)
        if request.method == 'POST':
            if form.validate_on_submit():
                site = s.query(Site).filter(Site.name==request.form['sitename']).first()
                os.chdir('/var/www/html/rstools/rstools/apps/lcm/sites/')
                os.system('rm -rf ' + site.name)
                s.delete(site)
                flash('Site {} verwijderd'.format(site.name))
                current_app.logger.info('User %s deleted a site', session['username'])
        return render_template('lcm_delete_site.html', form=form)


@lcm.route('/lcm/site_mgmt/get_sites')
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Site management, -> Opvragen sites')
def lcm_get_sites():
    result = []
    with session_scope() as s:
        sitenames = [site.name for site in s.query(Site).all()]
        for sitename in sorted(sitenames):
            row = {'SiteNaam': sitename}
            result.append(row)
    current_app.logger.info('User %s queried the sites', session['username'])
    return render_template('lcm_get_sites.html', result=result)


@lcm.route('/lcm/site_mgmt/select_site',  methods=['GET', 'POST'])
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Site management, -> Selecteren sites')
def lcm_select_site():
    with session_scope() as s:
        form = DeleteSiteForm(request.form)
        sitenames = [site.name for site in s.query(Site).all()]
        form.sitename.choices = sorted(sitenames)
        if request.method == 'POST':
            if form.validate_on_submit():
                site = s.query(Site).filter(Site.name==request.form['sitename']).first()
                session['sitename_select'] = site.name
                flash('Site {} geselecteerd'.format(site.name))
                current_app.logger.info('User %s selected site %s', session['username'], site.name)
                return redirect(url_for('lcm.lcm_main_menu'))
    return render_template('lcm_select_site.html', form=form)


@lcm.route('/lcm/site_mgmt/create_scripting_env')
@required_access_level('lcm_admin')
@breadcrumb('LCM, -> Site management, -> Maken scripting omgeving')
def lcm_create_scripting_env():
    if session.get('sitename_select'):
        sitename = session['sitename_select']
        text = scripts_wrapper('lcm_create_scripting_env', sitename)
        current_app.logger.info('User %s created scripting env', session['username'])
        current_app.logger.info('%s', text)
        return render_template('lcm_script.html', text=text, page='lcm.lcm_main_menu')
    else:
        error = 'U moet eerst een site selecteren'
        current_app.logger.info('User %s forget to select a site', session['username'])
        return render_template('lcm_site_mgmt_main_menu.html', error=error)


@lcm.route('/lcm/prepare_site/download_new_xls')
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Voorbereiden migratie, -> Download nieuw Excel bestand')
def lcm_download_new_xls():
    current_app.logger.info('User %s downloaded new Excel file', session['username'])
    return send_file('apps/lcm/empty_excel/result.xlsx', as_attachment=True)


@lcm.route('/lcm/prepare_site/upload_xls')
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Voorbereiden migratie, -> Upload Excel bestand')
def lcm_upload_xls():
    return render_template('lcm_upload_xls.html')


@lcm.route('/lcm/prepare_site/xls_uploader', methods = ['GET', 'POST'])
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Voorbereiden migratie, -> Upload Excel bestand')
def lcm_xls_uploader():
    if request.method == 'POST':
        curr_dir = os.getcwd()
        sitename = session['sitename_select']
        os.chdir('/var/www/html/rstools/rstools/apps/lcm/sites/' + sitename + '/lcm_env')
        current_app.logger.info('User %s uploaded an Excel file', session['username'])
        f = request.files['file']
        f.save(secure_filename(f.filename))
        flash('Bestand geupload')
        os.chdir(curr_dir)
        return render_template('lcm_prepare_site_main_menu.html')


@lcm.route('/lcm/prepare_site/download_archived_xls')
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Voorbereiden migratie, -> Download gearchiveerd Excel bestand')
def lcm_download_archived_xls():
    sitename = session['sitename_select']
    filename = '/var/www/html/rstools/rstools/apps/lcm/sites/' + sitename + '/configs/result.xlsx'
    current_app.logger.info('User %s downloaded an archived Excel file', session['username'])
    return send_file(filename, as_attachment=True)


@lcm.route('/lcm/prepare_site/download_current_xls')
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Voorbereiden migratie, -> Download huidig Excel bestand')
def lcm_download_current_xls():
    sitename = session['sitename_select']
    filename = '/var/www/html/rstools/rstools/apps/lcm/sites/' + sitename + '/lcm_env/result.xlsx'
    current_app.logger.info('User %s downloaded a current Excel file', session['username'])
    return send_file(filename, as_attachment=True)

@lcm.route('/lcm/prepare_site/lcm_old_inventory')
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Voorbereiden migratie, -> Maken inventory oude site')
def lcm_old_inventory():
    sitename = session['sitename_select']
    text = scripts_wrapper('lcm_old_inventory', sitename)
    current_app.logger.info('User %s created old inventory', session['username'])
    current_app.logger.info('%s', text)
    session['old_inventory'] = True
    return render_template('lcm_script.html', text=text, page='lcm.lcm_prepare_site_main_menu')


@lcm.route('/lcm/prepare_site/backup')
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Voorbereiden migratie, -> Maken backup configuraties')
def lcm_backup():
    sitename = session['sitename_select']
    if session.get('old_inventory'):
        session['backups_made'] = True
        text = scripts_wrapper('lcm_backup', sitename)
        current_app.logger.info('User %s backup old configs', session['username'])
        current_app.logger.info('%s', text)
    else:
        error = 'U moet eerst de inventory van de bestaande machines maken'
        current_app.logger.info('User %s forget to select inventory', session['username'])
        return render_template('lcm_prepare_site.html', error=error)
    return render_template('lcm_script.html', text=text, page='lcm.lcm_prepare_site_main_menu')


@lcm.route('/lcm/prepare_site/prepare')
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Voorbereiden migratie, -> Voorbereiden configuraties')
def lcm_prepare():
    if session.get('backups_made'):
        sitename = session['sitename_select']
        session['configs_prepared'] = True
        text = scripts_wrapper('lcm_prepare', sitename)
        current_app.logger.info('User %s prepared new configs', session['username'])
        current_app.logger.info('%s', text)
        return render_template('lcm_script.html', text=text, page='lcm.lcm_prepare_site_main_menu')
    else:
        error = 'U moet eerst backups van de bestaande machines maken'
        current_app.logger.info('User %s forget to backup configs', session['username'])
        return render_template('lcm_prepare_site_main_menu.html', error=error)


@lcm.route('/lcm/prepare_site/generate')
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Voorbereiden migratie, -> Genereren configuraties')
def lcm_generate():
    sitename = session['sitename_select']
    session['configs_generated'] = True
    text = scripts_wrapper('lcm_generate', sitename)
    current_app.logger.info('User %s created new configs', session['username'])
    current_app.logger.info('%s', text)
    return render_template('lcm_script.html', text=text, page='lcm.lcm_prepare_site_main_menu')


@lcm.route('/lcm/prepare_new_site/generate')
@required_access_level('lcm_user')
@breadcrumb('Nieuwe Site, -> Voorbereiden, -> Genereren configuraties')
def lcm_new_site_generate():
    sitename = session['sitename_select']
    text = scripts_wrapper('lcm_new_site_generate', sitename)
    current_app.logger.info('User %s created new configs for new site', session['username'])
    current_app.logger.info('%s', text)
    return render_template('lcm_script.html', text=text, page='lcm.lcm_prepare_site_main_menu')


@lcm.route('/lcm/prepare_site/download_cfgs')
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Voorbereiden migratie, -> Downloaden configuraties')
def lcm_download_cfgs():
    sitename = session['sitename_select']
    curr_dir = os.getcwd()
    os.chdir('/var/www/html/rstools/rstools/apps/lcm/sites/' + sitename + '/configs')
    file_dir = os.getcwd()
    filenames = [filename for filename in glob('*.txt')]
    with zipfile.ZipFile('all.zip', 'w', zipfile.ZIP_BZIP2) as zf:
        for filename in filenames:
            zf.write(os.path.join(file_dir, filename))
    filename = '/var/www/html/rstools/rstools/apps/lcm/sites/' + sitename + '/configs/all.zip'
    return send_file(filename, as_attachment=True)


@lcm.route('/lcm/migrate_site/save_state_info')
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Migratie site, -> Opslaan netwerktabellen')
def lcm_save_state_info():
    sitename = session['sitename_select']
    text = scripts_wrapper('lcm_save_state_info', sitename)
    current_app.logger.info('User %s saved state from old site', session['username'])
    current_app.logger.info('%s', text)
    return render_template('lcm_script.html', text=text, page='lcm.lcm_migrate_site_main_menu')


@lcm.route('/lcm/migrate_site/download_state_info')
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Migratie Site, -> Downloaden state info')
def lcm_download_state_info():
    sitename = session['sitename_select']
    curr_dir = os.getcwd()
    os.chdir('/var/www/html/rstools/rstools/apps/lcm/sites/' + sitename + '/lcm_env/state_info')
    file_dir = os.getcwd()
    filenames = [filename for filename in glob('*.state')]
    with zipfile.ZipFile('all.zip', 'w', zipfile.ZIP_BZIP2) as zf:
        for filename in filenames:
            zf.write(os.path.join(file_dir, filename))
    filename = '/var/www/html/rstools/rstools/apps/lcm/sites/' + sitename + '/lcm_env/state_info/all.zip'
    return send_file(filename, as_attachment=True)


@lcm.route('/lcm/migrate_site/staging_area')
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Migratie site, -> Copieer naar staging area')
def lcm_staging_area():
    sitename = session['sitename_select']
    text = scripts_wrapper('lcm_staging_area', sitename)
    current_app.logger.info('User %s coppied to staging area', session['username'])
    current_app.logger.info('%s', text)
    return render_template('lcm_script.html', text=text, page='lcm.lcm_migrate_site_main_menu')


@lcm.route('/lcm/migrate_site/select_filename_staging_area', methods = ['GET', 'POST'])
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Migratie site, -> Selecteer bestand uit staging area')
def lcm_migrate_select_filename_staging_area():
    sitename = session['sitename_select']
    filenames = os.listdir('/var/www/html/rstools/rstools/apps/lcm/sites/' + sitename + '/lcm_env/lcm_configs')
    form = SelectFileName(request.form)
    form.filename.choices = filenames
    if request.method == 'POST':
        if form.validate_on_submit():
            session['select_staging_filename'] = request.form['filename']
            flash('Volgende bestand {} geselecteerd'.format(request.form['filename']))
            return redirect(url_for('lcm.lcm_migrate_site_main_menu'))
    current_app.logger.info('User %s selected a filename from staging area', session['username'])
    return render_template('lcm_migrate_select_filename_staging_area.html', form=form)


@lcm.route('/lcm/migrate_site/download_file_staging_area')
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Migratie site, -> Download bestand uit staging area')
def lcm_migrate_download_name_staging_area():
    sitename = session['sitename_select']
    filename  = session['select_staging_filename']
    current_app.logger.info('User %s downloaded a file from staging area', session['username'])
    base_dir = '/var/www/html/rstools/rstools/apps/lcm/sites/' + sitename + '/lcm_env/lcm_configs/'
    return send_file(base_dir + filename, as_attachment=True)


@lcm.route('/lcm/migrate_site/upload_staging_area')
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Migratie site, -> Upload bestand naar staging area')
def lcm_migrate_site_upload_staging_area():
    return render_template('lcm_migrate_upload_staging_area.html')


@lcm.route('/lcm/migrate_site/staging_area_uploader', methods = ['GET', 'POST'])
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Migratie site, -> Upload bestand naar staging area')
def lcm_migrate_site_staging_area_uploader():
    if request.method == 'POST':
        curr_dir = os.getcwd()
        sitename = session['sitename_select']
        os.chdir('/var/www/html/rstools/rstools/apps/lcm/sites/' + sitename + '/lcm_env/lcm_configs/')
        current_app.logger.info('User %s uploaded a file to staging area', session['username'])
        f = request.files['file']
        f.save(secure_filename(f.filename))
        flash('Bestand geupload')
        os.chdir(curr_dir)
        return render_template('lcm_migrate_site_main_menu.html')


@lcm.route('/lcm/migrate_site/netmiko_inventory')
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Migratie site, -> Creeer een inventory')
def lcm_create_netmiko_inventory():
    session['inv_created'] = True
    sitename = session['sitename_select']
    text = scripts_wrapper('lcm_create_netmiko_inventory', sitename)
    current_app.logger.info('User %s selected a device', session['username'])
    current_app.logger.info('%s', text)
    return render_template('lcm_script.html', text=text, page='lcm.lcm_migrate_site_main_menu')


@lcm.route('/lcm/migrate_site/select_device', methods = ['GET', 'POST'])
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Migratie site, -> Selecteer een device')
def lcm_select_device():
    if session.get('inv_created'):
        sitename = session['sitename_select']
        curr_dir = os.getcwd()
        os.chdir('/var/www/html/rstools/rstools/apps/lcm/sites/' + sitename + '/lcm_env')
        with open('netmiko.json', 'r') as f:
            netmiko_info = json.load(f)
        os.chdir(curr_dir)
        form = SelectNetworkElement(request.form)
        form.devicename.choices = netmiko_info['netmiko_devicenames']
        form.ipaddress.choices = netmiko_info['netmiko_host_ips']
        if request.method == 'POST':
            if form.validate_on_submit():
                session['devicename'] = request.form['devicename']
                session['ipaddress'] = request.form['ipaddress']
                flash('Device {} met IP {} geselecteerd'.format(request.form['devicename'], request.form['ipaddress']))
                return redirect(url_for('lcm.lcm_migrate_site_main_menu'))
        current_app.logger.info('User %s selected a device', session['username'])
        return render_template('lcm_migrate_select_device.html', form=form)
    else:
        error = 'U moet eerst een inventory maken.'
        current_app.logger.info('User %s forget to create inventory', session['username'])
        return render_template('lcm_main_menu.html', error=error)


@lcm.route('/lcm/migrate_site/push_initial_cfg')
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Migratie site, -> Pushen initiele configuraties')
def lcm_push_initial_cfg():
    if session.get('inv_created') and session.get('devicename'):
        sitename = session['sitename_select']
        devicename = session['devicename']
        ipaddress = session['ipaddress']
        os.chdir('/var/www/html/rstools/rstools/apps/lcm/sites/' + sitename + '/lcm_env/ansible/')
        os.system('cp netmiko_utils.py ../lcm_configs')
        os.chdir('/var/www/html/rstools/rstools/apps/lcm/sites/' + sitename + '/lcm_env/lcm_configs')
        fmt = '-i {} -d {} -c {} -u {} -p {}'
        text = subprocess.getoutput(
            'python3 netmiko_utils.py ' + fmt.format(ipaddress, devicename, 'initial', 'cisco', 'cisco'))
        text = text.splitlines()
        if 'pyats' in text[0]: # remove first line if it contains pyats
            del text[0]
        text = "\n".join(text)
        current_app.logger.info('User %s pushed an initial config', session['username'])
        session['devicename'] = None
        return render_template('lcm_script.html', text=text, page='lcm.lcm_migrate_site_main_menu')
    else:
        error = 'U moet eerst een inventory maken en/of een device selecteren'
        current_app.logger.info('User %s forget to create inventory', session['username'])
        return render_template('lcm_main_menu.html', error=error)


@lcm.route('/lcm/migrate_site/push_after_cfg')
@required_access_level('lcm_user')
@breadcrumb('LCM, -> Migratie site, -> Pushen AAA configuraties')
def lcm_push_after_cfg():
    if session.get('inv_created') and session.get('devicename'):
        sitename = session['sitename_select']
        devicename = session['devicename']
        ipaddress = session['ipaddress']
        os.chdir('/var/www/html/rstools/rstools/apps/lcm/sites/' + sitename + '/lcm_env/ansible/')
        os.system('cp netmiko_utils.py ../lcm_configs')
        os.chdir('/var/www/html/rstools/rstools/apps/lcm/sites/' + sitename + '/lcm_env/lcm_configs/')
        fmt = '-i {} -d {} -c {} -u {} -p {}'
        text = subprocess.getoutput(
            'python3 netmiko_utils.py ' + fmt.format(ipaddress, devicename, 'after', 'cisco', 'cisco'))
        text = text.splitlines()
        if 'pyats' in text[0]: # remove first line if it contains pyats
            del text[0]
        text = "\n".join(text)
        current_app.logger.info('User %s pushed an after config', session['username'])
        current_app.logger.info('%s', text)
        session['devicename'] = None
        return render_template('lcm_script.html', text=text, page='lcm.lcm_migrate_site_main_menu')
    else:
        error = 'U moet eerst een inventory maken en/of een device selecteren'
        current_app.logger.info('User %s forget to select device', session['username'])
        return render_template('lcm_main_menu.html', error=error)
[isn78253@isivsx0024 lcm]$




[isn78253@isivsx0024 templates]$ cat *.html
{% extends "_base.html" %}
{% block content %}

<h1>Voeg een Site toe.</h1>
<br>

<form method="post" action="/rstools/lcm/site_mgmt/add_site">
    {{ form.csrf_token }}
    <div>
        {{ form.sitename.label }}
        <div>
            {{ form.sitename }}
        </div>
    </div>
    <br>
    <div>
        <button class="btn btn-sm btn-success bg-steel" type="log in">OK</button>
    </div>
</form>
{% endblock %}

{% extends "_base.html" %}
{% block content %}

<h1>Verwijder een Site.</h1>
<br>

<form method="post" action="/rstools/lcm/site_mgmt/delete_site">
    {{ form.csrf_token }}
    <div>
        {{ form.sitename.label }}
        <div>
            {{ form.sitename }}
        </div>
    </div>
    <br>
    <div>
        <button class="btn btn-sm btn-success bg-steel" type="log in">OK</button>
    </div>
</form>
{% endblock %}

{% extends "_base.html" %}
{% block content %}

{% from "_create_table.html" import create_table %}
<h1>Overzicht van alle Sites</h1>
<br>

{{ create_table(result) }}
{% endblock %}

{% extends "_base.html" %}
{% block content %}

<h1>Welkom in het LCM hoofdmenu.</h1>
<br>
<br>
<h3>Maak een keuze:</h3>

<div>
    <a href="{{ url_for('lcm.lcm_site_mgmt_main_menu') }}">Site management</a>
</div>

<div>
    <a href="{{ url_for('lcm.lcm_prepare_site_main_menu') }}">Voorbereiden migratie van een site</a>
</div>

<div>
    <a href="{{ url_for('lcm.lcm_migrate_site_main_menu') }}">Migratie van een site of oplevering nieuwe site</a>
</div>

{% endblock %}

{% extends "_base.html" %}
{% block content %}

<h1>Selecteer een Device.</h1>
<br>

<form method="post" action="/rstools/lcm/migrate_site/select_device">
    {{ form.csrf_token }}
    <div>
        {{ form.devicename.label }}
        <div>
            {{ form.devicename }}
        </div>
    </div>
    <br>
    <div>
        {{ form.ipaddress.label }}
        <div>
            {{ form.ipaddress }}
        </div>
    </div>
    <br>
    <div>
        <button class="btn btn-sm btn-success bg-steel" type="OK">OK</button>
    </div>
</form>

{% endblock %}
{% extends "_base.html" %}
{% block content %}

<h1>Selecteer een File naam.</h1>
<br>

<form method="post" action="/rstools/lcm/migrate_site/select_filename_staging_area">
    {{ form.csrf_token }}
    <div>
        {{ form.filename.label }}
        <div>
            {{ form.filename }}
        </div>
    </div>
    <br>
    <div>
        <button class="btn btn-sm btn-success bg-steel" type="OK">OK</button>
    </div>
</form>

{% endblock %}
{% extends "_base.html" %}
{% block content %}

<h1>Migreer een site (LCM) of activeer een nieuwe site</h1>
<br>
<h3>Maak een keuze:</h3>

<div>
    <a href="{{ url_for('lcm.lcm_save_state_info') }}" class="patient">Sla netwerktabellen van de huidige site op (LCM)</a>
</div>

<div>
        <a href="{{ url_for('lcm.lcm_download_state_info') }}" class="patient">Download de opgeslagen tabellen (LCM)</a>
</div>

<br>

<div>
    <a href="{{ url_for('lcm.lcm_staging_area') }}" class="patient">[eenmalig] Copieer configuraties naar de staging area</a>
</div>

<br>

<div>
    <a href="{{ url_for('lcm.lcm_migrate_select_filename_staging_area') }}" class="patient">Selecteer een bestand uit de staging area (optioneel)</a>
</div>

<div>
    <a href="{{ url_for('lcm.lcm_migrate_download_name_staging_area') }}" class="patient">Download een bestand uit de staging area (optioneel)</a>
</div>

<div>
    <a href="{{ url_for('lcm.lcm_migrate_site_upload_staging_area') }}" class="patient">Upload een bestand naar de staging area (optioneel)</a>
</div>

<br>

<div>
    <a href="{{ url_for('lcm.lcm_create_netmiko_inventory') }}" class="patient">Creeer een inventory</a>
</div>

<br>

<div>
    <a href="{{ url_for('lcm.lcm_select_device') }}" class="patient">Selecteer een netwerkelement</a>
</div>

<div>
    <a href="{{ url_for('lcm.lcm_push_initial_cfg') }}" class="patient">Push de initiele configuratie</a>
</div>

<br>

<div>
    <a href="{{ url_for('lcm.lcm_select_device') }}" class="patient">Selecteer een netwerkelement</a>
</div>

<div>
    <a href="{{ url_for('lcm.lcm_push_after_cfg') }}" class="patient">Push de AAA configuratie</a>
</div>

<br>

<div>
    <b>voeg handmatig de laatste 3 regels code toe</b>
</div>

<br>

{% endblock %}

{% extends "_base.html" %}
{% block content %}

<h1>Upload bestand naar staging area</h1>
<br>
<form method="post" action="/rstools/lcm/migrate_site/staging_area_uploader" enctype = "multipart/form-data">
    <input type = "file" name = "file" />
    <input type = "submit"/>
</form>
{% endblock %}

{% extends "/_base.html" %}
{% block content %}

<h1>Voorbereiden migratie van een site</h1>
<br>
<br>
<h3>Maak een keuze:</h3>

<div>
    <a href="{{ url_for('lcm.lcm_download_new_xls') }}" >Download een nieuw Excel bestand</a>
</div>

<div>
    <a href="{{ url_for('lcm.lcm_download_archived_xls') }}" >Download een gearchiveerd Excel bestand</a>
</div>

<br>

<div>
    <a href="{{ url_for('lcm.lcm_upload_xls') }}">Upload een Excel bestand</a>
</div>

<br>

<div>
    <a href="{{ url_for('lcm.lcm_old_inventory') }}" class="patient">Maak een inventory van de bestaande machines (LCM)</a >
</div>

<div>
    <a href="{{ url_for('lcm.lcm_backup') }}" class="patient">Maak backups van de bestaande machines (LCM)</a>
</div>

<br>

<div>
    <a href="{{ url_for('lcm.lcm_prepare') }} " class="patient">Bereid de configuraties voor (LCM)</a>
</div>

<div>
    <a href="{{ url_for('lcm.lcm_download_current_xls') }}" >Download een bestaand Excel bestand</a>
</div>

<div>
    <a href="{{ url_for('lcm.lcm_upload_xls') }}">Upload een Excel bestand</a>
</div>

<br>

<div>
    <a href="{{ url_for('lcm.lcm_generate') }} " class="patient">Genereer de configuraties (LCM)</a>
</div>

<br>

<div>
    <a href="{{ url_for('lcm.lcm_new_site_generate') }} " class="patient">Genereer de configuraties (Nieuwbouw)</a>
</div>

<br>

<div>
    <a href="{{ url_for('lcm.lcm_download_cfgs') }}">Download de configuraties</a>
</div>


{% endblock %}

{% extends "_base.html" %}
{% block content %}

<h1>Script resultaat</h1>
<br>
    <textarea class="scrollable">
    {{ text }}
    </textarea>
<div>
        <a href="{{ url_for(page) }}" class="btn btn-info bg-steel" role="button">Ga verder</a>
</div>

{% endblock %}
{% extends "_base.html" %}
{% block content %}

<h1>Selecteer een Site.</h1>
<br>

<form method="post" action="/rstools/lcm/site_mgmt/select_site">
        {{ form.csrf_token }}
    <div>
        {{ form.sitename.label }}
        <div>
            {{ form.sitename }}
        </div>
    </div>
    <br>
    <div>
        <button class="btn btn-sm btn-success bg-steel" type="log in">OK</button>
    </div>
</form>
{% endblock %}

{% extends "_base.html" %}
{% block content %}

<h1>Site management</h1>
<br>
<h3>Maak een keuze:</h3>

<div>
    <a href="{{ url_for('lcm.lcm_add_site') }}">Toevoegen van een site</a>
</div>

<div>
    <a href="{{ url_for('lcm.lcm_delete_site') }}">Verwijderen van een site</a>
</div>

<div>
    <a href="{{ url_for('lcm.lcm_get_sites') }}">Overzicht van de sites</a>
</div>
<br>
<div>
    <a href="{{ url_for('lcm.lcm_select_site') }}">Selecteren van een site</a>
</div>
<br>
<div>
    <a href="{{ url_for('lcm.lcm_create_scripting_env') }}">[eenmalig] Klaarzetten scripting omgeving</a>
</div>


{% endblock %}

{% extends "_base.html" %}
{% block content %}

<h1>Upload Excel bestand.</h1>
<br>
<form method="post" action="/rstools/lcm/prepare_site/xls_uploader" enctype = "multipart/form-data">
    <input type = "file" name = "file" />
    <input type = "submit"/>
</form>
{% endblock %}





















































